/*
 * generated by Xtext 2.9.2
 */
package org.xtext.example.mydsl.validation

import org.eclipse.xtext.validation.Check


import org.xtext.example.mydsl.myDsl.declaration
import org.xtext.example.mydsl.myDsl.simple_expression
import org.eclipse.emf.ecore.EReference
import org.xtext.example.mydsl.typing.ExpressionsTypeProvider
import org.xtext.example.mydsl.typing.ExpressionsType
import com.google.inject.Inject
import org.xtext.example.mydsl.myDsl.ADD

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {
	
//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	
	//@Check
	//def checkGreetingStartsWithCapital(declaration dec) {
	//	if (dec.declaration_specifiers.type_specifier.class != dec.init_declarator_list.init_declarator.initializer.assignment_expression.conditional_expression.simple_expression.class) {
	//			error('Atribuição não está de acordo com o tipo da variável',
	//				null);
	//	}
	//}
/* */	

@Inject extension ExpressionsTypeProvider
	
	@Check
	def checkType(ADD plus) {
		
		val leftType = getTypeAndCheckNotNull(plus.left,
				null)
		val rightType = getTypeAndCheckNotNull(plus.right,
				null)
		
		if (leftType == ExpressionsTypeProvider::intType
				|| rightType == ExpressionsTypeProvider::intType
				|| (leftType != ExpressionsTypeProvider::stringType && 
					rightType != ExpressionsTypeProvider::stringType)
					){
			checkNotBoolean(leftType, null)
			checkNotBoolean(rightType, null)
		}
	}
	
	@Check
	def checaAtribuicao(declaration dec){
		var tipo = dec.declaration_specifiers.type_specifier.typeFor
		var expression = dec.init_declarator_list.init_declarator.initializer
		if (expression != null){
			var expressiontype = getTypeAndCheckNotNull(dec.init_declarator_list.init_declarator.initializer,null)
			if (tipo != expressiontype){
				if(tipo == ExpressionsTypeProvider::floatType && expression.typeFor == ExpressionsTypeProvider::intType
					|| tipo == ExpressionsTypeProvider::boolType && expression.typeFor == ExpressionsTypeProvider::intType
				) return;
			
				error("Tipo da expressão é diferente do tipo da variável", null)
				
			}
		}
	}
	
	def private checkNotBoolean(ExpressionsType type, EReference reference) {
		if (type == ExpressionsTypeProvider::boolType) {
			error("cannot be boolean", reference, "deu.erro.com")
		}
	}
	
	
	def private checkExpectedBoolean(simple_expression exp, EReference reference) {
		checkExpectedType(exp, ExpressionsTypeProvider::boolType, reference)
	}

	def private checkExpectedInt(simple_expression exp, EReference reference) {
		checkExpectedType(exp, ExpressionsTypeProvider::intType, reference)
	}
	
	def private checkExpectedType(simple_expression exp,
			ExpressionsType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("expected " + expectedType + " type, but was " + actualType,
					reference, "erro.deu.erro")
	}
	
	def private ExpressionsType getTypeAndCheckNotNull(simple_expression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("Operação não suportada", reference, "erro.deu.erro")
		return type;
	}


}
