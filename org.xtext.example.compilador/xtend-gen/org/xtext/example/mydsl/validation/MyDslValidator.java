/**
 * generated by Xtext 2.9.2
 */
package org.xtext.example.mydsl.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.xtext.example.mydsl.myDsl.ADD;
import org.xtext.example.mydsl.myDsl.simple_expression;
import org.xtext.example.mydsl.typing.ExpressionsType;
import org.xtext.example.mydsl.typing.ExpressionsTypeProvider;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  @Inject
  @Extension
  private ExpressionsTypeProvider _expressionsTypeProvider;
  
  @Check
  public void checkType(final ADD plus) {
    simple_expression _left = plus.getLeft();
    final ExpressionsType leftType = this.getTypeAndCheckNotNull(_left, 
      null);
    simple_expression _right = plus.getRight();
    final ExpressionsType rightType = this.getTypeAndCheckNotNull(_right, 
      null);
    boolean _or = false;
    boolean _or_1 = false;
    boolean _equals = Objects.equal(leftType, ExpressionsTypeProvider.intType);
    if (_equals) {
      _or_1 = true;
    } else {
      boolean _equals_1 = Objects.equal(rightType, ExpressionsTypeProvider.intType);
      _or_1 = _equals_1;
    }
    if (_or_1) {
      _or = true;
    } else {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(leftType, ExpressionsTypeProvider.stringType));
      if (!_notEquals) {
        _and = false;
      } else {
        boolean _notEquals_1 = (!Objects.equal(rightType, ExpressionsTypeProvider.stringType));
        _and = _notEquals_1;
      }
      _or = _and;
    }
    if (_or) {
      this.checkNotBoolean(leftType, null);
      this.checkNotBoolean(rightType, null);
    }
  }
  
  private void checkNotBoolean(final ExpressionsType type, final EReference reference) {
    boolean _equals = Objects.equal(type, ExpressionsTypeProvider.boolType);
    if (_equals) {
      this.error("cannot be boolean", reference, "deu.erro.com");
    }
  }
  
  private void checkExpectedBoolean(final simple_expression exp, final EReference reference) {
    this.checkExpectedType(exp, ExpressionsTypeProvider.boolType, reference);
  }
  
  private void checkExpectedInt(final simple_expression exp, final EReference reference) {
    this.checkExpectedType(exp, ExpressionsTypeProvider.intType, reference);
  }
  
  private void checkExpectedType(final simple_expression exp, final ExpressionsType expectedType, final EReference reference) {
    final ExpressionsType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(((("expected " + expectedType) + " type, but was ") + actualType), reference, "erro.deu.erro");
    }
  }
  
  private ExpressionsType getTypeAndCheckNotNull(final simple_expression exp, final EReference reference) {
    ExpressionsType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._expressionsTypeProvider.typeFor(exp);
    }
    ExpressionsType type = _typeFor;
    boolean _equals = Objects.equal(type, null);
    if (_equals) {
      this.error("null type", reference, "erro.deu.erro");
    }
    return type;
  }
}
