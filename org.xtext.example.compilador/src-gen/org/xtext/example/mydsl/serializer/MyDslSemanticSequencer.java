/*
 * generated by Xtext 2.9.2
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.ADD;
import org.xtext.example.mydsl.myDsl.AND;
import org.xtext.example.mydsl.myDsl.EQL;
import org.xtext.example.mydsl.myDsl.EXC_OR;
import org.xtext.example.mydsl.myDsl.INC_OR;
import org.xtext.example.mydsl.myDsl.LOG_AND;
import org.xtext.example.mydsl.myDsl.LOG_OR;
import org.xtext.example.mydsl.myDsl.MINUS;
import org.xtext.example.mydsl.myDsl.MUL;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.REL;
import org.xtext.example.mydsl.myDsl.SHF;
import org.xtext.example.mydsl.myDsl.abstract_declarator;
import org.xtext.example.mydsl.myDsl.alignment_specifier;
import org.xtext.example.mydsl.myDsl.argument_expression_list;
import org.xtext.example.mydsl.myDsl.assignment_expression;
import org.xtext.example.mydsl.myDsl.assignment_operator;
import org.xtext.example.mydsl.myDsl.atomic_type_specifier;
import org.xtext.example.mydsl.myDsl.block_item;
import org.xtext.example.mydsl.myDsl.booleanType;
import org.xtext.example.mydsl.myDsl.charType;
import org.xtext.example.mydsl.myDsl.complexType;
import org.xtext.example.mydsl.myDsl.compound_statement;
import org.xtext.example.mydsl.myDsl.conditional_expression;
import org.xtext.example.mydsl.myDsl.constant;
import org.xtext.example.mydsl.myDsl.constant_expression;
import org.xtext.example.mydsl.myDsl.declaration;
import org.xtext.example.mydsl.myDsl.declaration_list;
import org.xtext.example.mydsl.myDsl.declaration_list2;
import org.xtext.example.mydsl.myDsl.declaration_specifiers;
import org.xtext.example.mydsl.myDsl.declarator;
import org.xtext.example.mydsl.myDsl.designation;
import org.xtext.example.mydsl.myDsl.designator;
import org.xtext.example.mydsl.myDsl.designator_list;
import org.xtext.example.mydsl.myDsl.designator_list2;
import org.xtext.example.mydsl.myDsl.direct_abstract_declarator;
import org.xtext.example.mydsl.myDsl.direct_abstract_declarator2;
import org.xtext.example.mydsl.myDsl.direct_declarator;
import org.xtext.example.mydsl.myDsl.direct_declarator2;
import org.xtext.example.mydsl.myDsl.doubleType;
import org.xtext.example.mydsl.myDsl.enum_specifier;
import org.xtext.example.mydsl.myDsl.enumeration_constant;
import org.xtext.example.mydsl.myDsl.enumerator;
import org.xtext.example.mydsl.myDsl.enumerator_list;
import org.xtext.example.mydsl.myDsl.enumerator_list2;
import org.xtext.example.mydsl.myDsl.expression;
import org.xtext.example.mydsl.myDsl.expression2;
import org.xtext.example.mydsl.myDsl.expression_statement;
import org.xtext.example.mydsl.myDsl.external_declaration;
import org.xtext.example.mydsl.myDsl.floatType;
import org.xtext.example.mydsl.myDsl.function_definition;
import org.xtext.example.mydsl.myDsl.function_specifier;
import org.xtext.example.mydsl.myDsl.generic_assoc_list;
import org.xtext.example.mydsl.myDsl.generic_association;
import org.xtext.example.mydsl.myDsl.generic_selection;
import org.xtext.example.mydsl.myDsl.identifier_list;
import org.xtext.example.mydsl.myDsl.identifier_list2;
import org.xtext.example.mydsl.myDsl.imaginaryType;
import org.xtext.example.mydsl.myDsl.init_declarator;
import org.xtext.example.mydsl.myDsl.init_declarator_list;
import org.xtext.example.mydsl.myDsl.init_declarator_list2;
import org.xtext.example.mydsl.myDsl.initializer;
import org.xtext.example.mydsl.myDsl.initializer_list;
import org.xtext.example.mydsl.myDsl.initializer_list2;
import org.xtext.example.mydsl.myDsl.intType;
import org.xtext.example.mydsl.myDsl.iteration_statement;
import org.xtext.example.mydsl.myDsl.jump_statement;
import org.xtext.example.mydsl.myDsl.labeled_statement;
import org.xtext.example.mydsl.myDsl.longType;
import org.xtext.example.mydsl.myDsl.parameter_declaration;
import org.xtext.example.mydsl.myDsl.parameter_list;
import org.xtext.example.mydsl.myDsl.parameter_list2;
import org.xtext.example.mydsl.myDsl.parameter_type_list;
import org.xtext.example.mydsl.myDsl.pointer;
import org.xtext.example.mydsl.myDsl.postfix_expression;
import org.xtext.example.mydsl.myDsl.selection_statement;
import org.xtext.example.mydsl.myDsl.shortType;
import org.xtext.example.mydsl.myDsl.signedType;
import org.xtext.example.mydsl.myDsl.simple_expression;
import org.xtext.example.mydsl.myDsl.specifier_qualifier_list;
import org.xtext.example.mydsl.myDsl.statement;
import org.xtext.example.mydsl.myDsl.static_assert_declaration;
import org.xtext.example.mydsl.myDsl.storage_class_specifier;
import org.xtext.example.mydsl.myDsl.stringType;
import org.xtext.example.mydsl.myDsl.string_nova;
import org.xtext.example.mydsl.myDsl.struct_declaration;
import org.xtext.example.mydsl.myDsl.struct_declaration_list;
import org.xtext.example.mydsl.myDsl.struct_declaration_list2;
import org.xtext.example.mydsl.myDsl.struct_declarator;
import org.xtext.example.mydsl.myDsl.struct_declarator_list;
import org.xtext.example.mydsl.myDsl.struct_declarator_list2;
import org.xtext.example.mydsl.myDsl.struct_or_union;
import org.xtext.example.mydsl.myDsl.struct_or_union_specifier;
import org.xtext.example.mydsl.myDsl.translation_unit;
import org.xtext.example.mydsl.myDsl.type_name;
import org.xtext.example.mydsl.myDsl.type_qualifier;
import org.xtext.example.mydsl.myDsl.type_qualifier_list;
import org.xtext.example.mydsl.myDsl.type_qualifier_list2;
import org.xtext.example.mydsl.myDsl.type_specifier;
import org.xtext.example.mydsl.myDsl.unary_expression;
import org.xtext.example.mydsl.myDsl.unsignedType;
import org.xtext.example.mydsl.myDsl.variableRef;
import org.xtext.example.mydsl.myDsl.voidType;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ADD:
				sequence_additive_expression(context, (ADD) semanticObject); 
				return; 
			case MyDslPackage.AND:
				sequence_and_expression(context, (AND) semanticObject); 
				return; 
			case MyDslPackage.EQL:
				sequence_equality_expression(context, (EQL) semanticObject); 
				return; 
			case MyDslPackage.EXC_OR:
				sequence_exclusive_or_expression(context, (EXC_OR) semanticObject); 
				return; 
			case MyDslPackage.INC_OR:
				sequence_inclusive_or_expression(context, (INC_OR) semanticObject); 
				return; 
			case MyDslPackage.LOG_AND:
				sequence_logical_and_expression(context, (LOG_AND) semanticObject); 
				return; 
			case MyDslPackage.LOG_OR:
				sequence_logical_or_expression(context, (LOG_OR) semanticObject); 
				return; 
			case MyDslPackage.MINUS:
				sequence_additive_expression(context, (MINUS) semanticObject); 
				return; 
			case MyDslPackage.MUL:
				sequence_multiplicative_expression(context, (MUL) semanticObject); 
				return; 
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.REL:
				sequence_relational_expression(context, (REL) semanticObject); 
				return; 
			case MyDslPackage.SHF:
				sequence_shift_expression(context, (SHF) semanticObject); 
				return; 
			case MyDslPackage.ABSTRACT_DECLARATOR:
				sequence_abstract_declarator(context, (abstract_declarator) semanticObject); 
				return; 
			case MyDslPackage.ALIGNMENT_SPECIFIER:
				sequence_alignment_specifier(context, (alignment_specifier) semanticObject); 
				return; 
			case MyDslPackage.ARGUMENT_EXPRESSION_LIST:
				sequence_argument_expression_list(context, (argument_expression_list) semanticObject); 
				return; 
			case MyDslPackage.ASSIGNMENT_EXPRESSION:
				sequence_assignment_expression(context, (assignment_expression) semanticObject); 
				return; 
			case MyDslPackage.ASSIGNMENT_OPERATOR:
				sequence_assignment_operator(context, (assignment_operator) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_TYPE_SPECIFIER:
				sequence_atomic_type_specifier(context, (atomic_type_specifier) semanticObject); 
				return; 
			case MyDslPackage.BLOCK_ITEM:
				sequence_block_item(context, (block_item) semanticObject); 
				return; 
			case MyDslPackage.BOOLEAN_TYPE:
				if (rule == grammarAccess.getPrimary_expressionRule()
						|| rule == grammarAccess.getAtomic2Rule()
						|| rule == grammarAccess.getMultiplicative_expressionRule()
						|| action == grammarAccess.getMultiplicative_expressionAccess().getMULLeftAction_1_0()
						|| rule == grammarAccess.getAdditive_expressionRule()
						|| action == grammarAccess.getAdditive_expressionAccess().getADDLeftAction_1_0_0_0()
						|| action == grammarAccess.getAdditive_expressionAccess().getMINUSLeftAction_1_0_1_0()
						|| rule == grammarAccess.getShift_expressionRule()
						|| action == grammarAccess.getShift_expressionAccess().getSHFLeftAction_1_0()
						|| rule == grammarAccess.getRelational_expressionRule()
						|| action == grammarAccess.getRelational_expressionAccess().getRELLeftAction_1_0()
						|| rule == grammarAccess.getEquality_expressionRule()
						|| action == grammarAccess.getEquality_expressionAccess().getEQLLeftAction_1_0()
						|| rule == grammarAccess.getAnd_expressionRule()
						|| action == grammarAccess.getAnd_expressionAccess().getANDLeftAction_1_0()
						|| rule == grammarAccess.getExclusive_or_expressionRule()
						|| action == grammarAccess.getExclusive_or_expressionAccess().getEXC_ORLeftAction_1_0()
						|| rule == grammarAccess.getInclusive_or_expressionRule()
						|| action == grammarAccess.getInclusive_or_expressionAccess().getINC_ORLeftAction_1_0()
						|| rule == grammarAccess.getLogical_and_expressionRule()
						|| action == grammarAccess.getLogical_and_expressionAccess().getLOG_ANDLeftAction_1_0()
						|| rule == grammarAccess.getLogical_or_expressionRule()
						|| action == grammarAccess.getLogical_or_expressionAccess().getLOG_ORLeftAction_1_0()
						|| rule == grammarAccess.getSimple_expressionRule()) {
					sequence_atomic2(context, (booleanType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getType_specifierRule()) {
					sequence_type_specifier(context, (booleanType) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.CHAR_TYPE:
				sequence_type_specifier(context, (charType) semanticObject); 
				return; 
			case MyDslPackage.COMPLEX_TYPE:
				sequence_type_specifier(context, (complexType) semanticObject); 
				return; 
			case MyDslPackage.COMPOUND_STATEMENT:
				sequence_compound_statement(context, (compound_statement) semanticObject); 
				return; 
			case MyDslPackage.CONDITIONAL_EXPRESSION:
				sequence_conditional_expression(context, (conditional_expression) semanticObject); 
				return; 
			case MyDslPackage.CONSTANT:
				sequence_constant(context, (constant) semanticObject); 
				return; 
			case MyDslPackage.CONSTANT_EXPRESSION:
				sequence_constant_expression(context, (constant_expression) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION:
				sequence_declaration(context, (declaration) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_LIST:
				sequence_declaration_list(context, (declaration_list) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_LIST2:
				sequence_declaration_list2(context, (declaration_list2) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_SPECIFIERS:
				sequence_declaration_specifiers(context, (declaration_specifiers) semanticObject); 
				return; 
			case MyDslPackage.DECLARATOR:
				sequence_declarator(context, (declarator) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATION:
				sequence_designation(context, (designation) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR:
				sequence_designator(context, (designator) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR_LIST:
				sequence_designator_list(context, (designator_list) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR_LIST2:
				sequence_designator_list2(context, (designator_list2) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_ABSTRACT_DECLARATOR:
				sequence_direct_abstract_declarator(context, (direct_abstract_declarator) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_ABSTRACT_DECLARATOR2:
				sequence_direct_abstract_declarator2(context, (direct_abstract_declarator2) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_DECLARATOR:
				sequence_direct_declarator(context, (direct_declarator) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_DECLARATOR2:
				sequence_direct_declarator2(context, (direct_declarator2) semanticObject); 
				return; 
			case MyDslPackage.DOUBLE_TYPE:
				sequence_type_specifier(context, (doubleType) semanticObject); 
				return; 
			case MyDslPackage.ENUM_SPECIFIER:
				sequence_enum_specifier(context, (enum_specifier) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATION_CONSTANT:
				sequence_enumeration_constant(context, (enumeration_constant) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATOR:
				sequence_enumerator(context, (enumerator) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATOR_LIST:
				sequence_enumerator_list(context, (enumerator_list) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATOR_LIST2:
				sequence_enumerator_list2(context, (enumerator_list2) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION2:
				sequence_expression2(context, (expression2) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION_STATEMENT:
				sequence_expression_statement(context, (expression_statement) semanticObject); 
				return; 
			case MyDslPackage.EXTERNAL_DECLARATION:
				sequence_external_declaration(context, (external_declaration) semanticObject); 
				return; 
			case MyDslPackage.FLOAT_TYPE:
				if (rule == grammarAccess.getPrimary_expressionRule()
						|| rule == grammarAccess.getAtomic2Rule()
						|| rule == grammarAccess.getMultiplicative_expressionRule()
						|| action == grammarAccess.getMultiplicative_expressionAccess().getMULLeftAction_1_0()
						|| rule == grammarAccess.getAdditive_expressionRule()
						|| action == grammarAccess.getAdditive_expressionAccess().getADDLeftAction_1_0_0_0()
						|| action == grammarAccess.getAdditive_expressionAccess().getMINUSLeftAction_1_0_1_0()
						|| rule == grammarAccess.getShift_expressionRule()
						|| action == grammarAccess.getShift_expressionAccess().getSHFLeftAction_1_0()
						|| rule == grammarAccess.getRelational_expressionRule()
						|| action == grammarAccess.getRelational_expressionAccess().getRELLeftAction_1_0()
						|| rule == grammarAccess.getEquality_expressionRule()
						|| action == grammarAccess.getEquality_expressionAccess().getEQLLeftAction_1_0()
						|| rule == grammarAccess.getAnd_expressionRule()
						|| action == grammarAccess.getAnd_expressionAccess().getANDLeftAction_1_0()
						|| rule == grammarAccess.getExclusive_or_expressionRule()
						|| action == grammarAccess.getExclusive_or_expressionAccess().getEXC_ORLeftAction_1_0()
						|| rule == grammarAccess.getInclusive_or_expressionRule()
						|| action == grammarAccess.getInclusive_or_expressionAccess().getINC_ORLeftAction_1_0()
						|| rule == grammarAccess.getLogical_and_expressionRule()
						|| action == grammarAccess.getLogical_and_expressionAccess().getLOG_ANDLeftAction_1_0()
						|| rule == grammarAccess.getLogical_or_expressionRule()
						|| action == grammarAccess.getLogical_or_expressionAccess().getLOG_ORLeftAction_1_0()
						|| rule == grammarAccess.getSimple_expressionRule()) {
					sequence_atomic2(context, (floatType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getType_specifierRule()) {
					sequence_type_specifier(context, (floatType) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.FUNCTION_DEFINITION:
				sequence_function_definition(context, (function_definition) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_SPECIFIER:
				sequence_function_specifier(context, (function_specifier) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_ASSOC_LIST:
				sequence_generic_assoc_list(context, (generic_assoc_list) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_ASSOCIATION:
				sequence_generic_association(context, (generic_association) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_SELECTION:
				sequence_generic_selection(context, (generic_selection) semanticObject); 
				return; 
			case MyDslPackage.IDENTIFIER_LIST:
				sequence_identifier_list(context, (identifier_list) semanticObject); 
				return; 
			case MyDslPackage.IDENTIFIER_LIST2:
				sequence_identifier_list2(context, (identifier_list2) semanticObject); 
				return; 
			case MyDslPackage.IMAGINARY_TYPE:
				sequence_type_specifier(context, (imaginaryType) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR:
				sequence_init_declarator(context, (init_declarator) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR_LIST:
				sequence_init_declarator_list(context, (init_declarator_list) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR_LIST2:
				sequence_init_declarator_list2(context, (init_declarator_list2) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER:
				sequence_initializer(context, (initializer) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER_LIST:
				sequence_initializer_list(context, (initializer_list) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER_LIST2:
				sequence_initializer_list2(context, (initializer_list2) semanticObject); 
				return; 
			case MyDslPackage.INT_TYPE:
				if (rule == grammarAccess.getPrimary_expressionRule()
						|| rule == grammarAccess.getAtomic2Rule()
						|| rule == grammarAccess.getMultiplicative_expressionRule()
						|| action == grammarAccess.getMultiplicative_expressionAccess().getMULLeftAction_1_0()
						|| rule == grammarAccess.getAdditive_expressionRule()
						|| action == grammarAccess.getAdditive_expressionAccess().getADDLeftAction_1_0_0_0()
						|| action == grammarAccess.getAdditive_expressionAccess().getMINUSLeftAction_1_0_1_0()
						|| rule == grammarAccess.getShift_expressionRule()
						|| action == grammarAccess.getShift_expressionAccess().getSHFLeftAction_1_0()
						|| rule == grammarAccess.getRelational_expressionRule()
						|| action == grammarAccess.getRelational_expressionAccess().getRELLeftAction_1_0()
						|| rule == grammarAccess.getEquality_expressionRule()
						|| action == grammarAccess.getEquality_expressionAccess().getEQLLeftAction_1_0()
						|| rule == grammarAccess.getAnd_expressionRule()
						|| action == grammarAccess.getAnd_expressionAccess().getANDLeftAction_1_0()
						|| rule == grammarAccess.getExclusive_or_expressionRule()
						|| action == grammarAccess.getExclusive_or_expressionAccess().getEXC_ORLeftAction_1_0()
						|| rule == grammarAccess.getInclusive_or_expressionRule()
						|| action == grammarAccess.getInclusive_or_expressionAccess().getINC_ORLeftAction_1_0()
						|| rule == grammarAccess.getLogical_and_expressionRule()
						|| action == grammarAccess.getLogical_and_expressionAccess().getLOG_ANDLeftAction_1_0()
						|| rule == grammarAccess.getLogical_or_expressionRule()
						|| action == grammarAccess.getLogical_or_expressionAccess().getLOG_ORLeftAction_1_0()
						|| rule == grammarAccess.getSimple_expressionRule()) {
					sequence_atomic2(context, (intType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getType_specifierRule()) {
					sequence_type_specifier(context, (intType) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.ITERATION_STATEMENT:
				sequence_iteration_statement(context, (iteration_statement) semanticObject); 
				return; 
			case MyDslPackage.JUMP_STATEMENT:
				sequence_jump_statement(context, (jump_statement) semanticObject); 
				return; 
			case MyDslPackage.LABELED_STATEMENT:
				sequence_labeled_statement(context, (labeled_statement) semanticObject); 
				return; 
			case MyDslPackage.LONG_TYPE:
				sequence_type_specifier(context, (longType) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_DECLARATION:
				sequence_parameter_declaration(context, (parameter_declaration) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_LIST:
				sequence_parameter_list(context, (parameter_list) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_LIST2:
				sequence_parameter_list2(context, (parameter_list2) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_TYPE_LIST:
				sequence_parameter_type_list(context, (parameter_type_list) semanticObject); 
				return; 
			case MyDslPackage.POINTER:
				sequence_pointer(context, (pointer) semanticObject); 
				return; 
			case MyDslPackage.POSTFIX_EXPRESSION:
				sequence_postfix_expression(context, (postfix_expression) semanticObject); 
				return; 
			case MyDslPackage.SELECTION_STATEMENT:
				sequence_selection_statement(context, (selection_statement) semanticObject); 
				return; 
			case MyDslPackage.SHORT_TYPE:
				sequence_type_specifier(context, (shortType) semanticObject); 
				return; 
			case MyDslPackage.SIGNED_TYPE:
				sequence_type_specifier(context, (signedType) semanticObject); 
				return; 
			case MyDslPackage.SIMPLE_EXPRESSION:
				sequence_cast_expression(context, (simple_expression) semanticObject); 
				return; 
			case MyDslPackage.SPECIFIER_QUALIFIER_LIST:
				sequence_specifier_qualifier_list(context, (specifier_qualifier_list) semanticObject); 
				return; 
			case MyDslPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case MyDslPackage.STATIC_ASSERT_DECLARATION:
				sequence_static_assert_declaration(context, (static_assert_declaration) semanticObject); 
				return; 
			case MyDslPackage.STORAGE_CLASS_SPECIFIER:
				sequence_storage_class_specifier(context, (storage_class_specifier) semanticObject); 
				return; 
			case MyDslPackage.STRING_TYPE:
				sequence_atomic2(context, (stringType) semanticObject); 
				return; 
			case MyDslPackage.STRING_NOVA:
				sequence_string_nova(context, (string_nova) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION:
				sequence_struct_declaration(context, (struct_declaration) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION_LIST:
				sequence_struct_declaration_list(context, (struct_declaration_list) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION_LIST2:
				sequence_struct_declaration_list2(context, (struct_declaration_list2) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR:
				sequence_struct_declarator(context, (struct_declarator) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR_LIST:
				sequence_struct_declarator_list(context, (struct_declarator_list) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR_LIST2:
				sequence_struct_declarator_list2(context, (struct_declarator_list2) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_OR_UNION:
				if (rule == grammarAccess.getStruct_or_unionRule()) {
					sequence_struct_or_union(context, (struct_or_union) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStruct_or_union_specifierRule()) {
					sequence_struct_or_union_struct_or_union_specifier(context, (struct_or_union) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.STRUCT_OR_UNION_SPECIFIER:
				sequence_struct_or_union_specifier(context, (struct_or_union_specifier) semanticObject); 
				return; 
			case MyDslPackage.TRANSLATION_UNIT:
				sequence_translation_unit(context, (translation_unit) semanticObject); 
				return; 
			case MyDslPackage.TYPE_NAME:
				sequence_type_name(context, (type_name) semanticObject); 
				return; 
			case MyDslPackage.TYPE_QUALIFIER:
				sequence_type_qualifier(context, (type_qualifier) semanticObject); 
				return; 
			case MyDslPackage.TYPE_QUALIFIER_LIST:
				sequence_type_qualifier_list(context, (type_qualifier_list) semanticObject); 
				return; 
			case MyDslPackage.TYPE_QUALIFIER_LIST2:
				sequence_type_qualifier_list2(context, (type_qualifier_list2) semanticObject); 
				return; 
			case MyDslPackage.TYPE_SPECIFIER:
				sequence_type_specifier(context, (type_specifier) semanticObject); 
				return; 
			case MyDslPackage.UNARY_EXPRESSION:
				sequence_unary_expression(context, (unary_expression) semanticObject); 
				return; 
			case MyDslPackage.UNSIGNED_TYPE:
				sequence_type_specifier(context, (unsignedType) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_REF:
				sequence_atomic2(context, (variableRef) semanticObject); 
				return; 
			case MyDslPackage.VOID_TYPE:
				sequence_type_specifier(context, (voidType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     declaracoes+=translation_unit+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     abstract_declarator returns abstract_declarator
	 *
	 * Constraint:
	 *     ((pointer=pointer direct_abstract_declarator=direct_abstract_declarator) | pointer=pointer | direct_abstract_declarator=direct_abstract_declarator)
	 */
	protected void sequence_abstract_declarator(ISerializationContext context, abstract_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns ADD
	 *     multiplicative_expression returns ADD
	 *     multiplicative_expression.MUL_1_0 returns ADD
	 *     additive_expression returns ADD
	 *     additive_expression.ADD_1_0_0_0 returns ADD
	 *     additive_expression.MINUS_1_0_1_0 returns ADD
	 *     shift_expression returns ADD
	 *     shift_expression.SHF_1_0 returns ADD
	 *     relational_expression returns ADD
	 *     relational_expression.REL_1_0 returns ADD
	 *     equality_expression returns ADD
	 *     equality_expression.EQL_1_0 returns ADD
	 *     and_expression returns ADD
	 *     and_expression.AND_1_0 returns ADD
	 *     exclusive_or_expression returns ADD
	 *     exclusive_or_expression.EXC_OR_1_0 returns ADD
	 *     inclusive_or_expression returns ADD
	 *     inclusive_or_expression.INC_OR_1_0 returns ADD
	 *     logical_and_expression returns ADD
	 *     logical_and_expression.LOG_AND_1_0 returns ADD
	 *     logical_or_expression returns ADD
	 *     logical_or_expression.LOG_OR_1_0 returns ADD
	 *     simple_expression returns ADD
	 *
	 * Constraint:
	 *     (left=additive_expression_ADD_1_0_0_0 right=multiplicative_expression)
	 */
	protected void sequence_additive_expression(ISerializationContext context, ADD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADD__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADD__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADD__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADD__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditive_expressionAccess().getADDLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditive_expressionAccess().getRightMultiplicative_expressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns MINUS
	 *     multiplicative_expression returns MINUS
	 *     multiplicative_expression.MUL_1_0 returns MINUS
	 *     additive_expression returns MINUS
	 *     additive_expression.ADD_1_0_0_0 returns MINUS
	 *     additive_expression.MINUS_1_0_1_0 returns MINUS
	 *     shift_expression returns MINUS
	 *     shift_expression.SHF_1_0 returns MINUS
	 *     relational_expression returns MINUS
	 *     relational_expression.REL_1_0 returns MINUS
	 *     equality_expression returns MINUS
	 *     equality_expression.EQL_1_0 returns MINUS
	 *     and_expression returns MINUS
	 *     and_expression.AND_1_0 returns MINUS
	 *     exclusive_or_expression returns MINUS
	 *     exclusive_or_expression.EXC_OR_1_0 returns MINUS
	 *     inclusive_or_expression returns MINUS
	 *     inclusive_or_expression.INC_OR_1_0 returns MINUS
	 *     logical_and_expression returns MINUS
	 *     logical_and_expression.LOG_AND_1_0 returns MINUS
	 *     logical_or_expression returns MINUS
	 *     logical_or_expression.LOG_OR_1_0 returns MINUS
	 *     simple_expression returns MINUS
	 *
	 * Constraint:
	 *     (left=additive_expression_MINUS_1_0_1_0 right=multiplicative_expression)
	 */
	protected void sequence_additive_expression(ISerializationContext context, MINUS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditive_expressionAccess().getMINUSLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditive_expressionAccess().getRightMultiplicative_expressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     alignment_specifier returns alignment_specifier
	 *
	 * Constraint:
	 *     ((alignas=ALIGNAS type_name=type_name) | (alignas=ALIGNAS constant_expression=constant_expression))
	 */
	protected void sequence_alignment_specifier(ISerializationContext context, alignment_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns AND
	 *     multiplicative_expression returns AND
	 *     multiplicative_expression.MUL_1_0 returns AND
	 *     additive_expression returns AND
	 *     additive_expression.ADD_1_0_0_0 returns AND
	 *     additive_expression.MINUS_1_0_1_0 returns AND
	 *     shift_expression returns AND
	 *     shift_expression.SHF_1_0 returns AND
	 *     relational_expression returns AND
	 *     relational_expression.REL_1_0 returns AND
	 *     equality_expression returns AND
	 *     equality_expression.EQL_1_0 returns AND
	 *     and_expression returns AND
	 *     and_expression.AND_1_0 returns AND
	 *     exclusive_or_expression returns AND
	 *     exclusive_or_expression.EXC_OR_1_0 returns AND
	 *     inclusive_or_expression returns AND
	 *     inclusive_or_expression.INC_OR_1_0 returns AND
	 *     logical_and_expression returns AND
	 *     logical_and_expression.LOG_AND_1_0 returns AND
	 *     logical_or_expression returns AND
	 *     logical_or_expression.LOG_OR_1_0 returns AND
	 *     simple_expression returns AND
	 *
	 * Constraint:
	 *     (left=and_expression_AND_1_0 right=equality_expression)
	 */
	protected void sequence_and_expression(ISerializationContext context, AND semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_expressionAccess().getANDLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAnd_expressionAccess().getRightEquality_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expression2 returns argument_expression_list
	 *     argument_expression_list returns argument_expression_list
	 *
	 * Constraint:
	 *     (assignment_expression=assignment_expression list+=assignment_expression*)
	 */
	protected void sequence_argument_expression_list(ISerializationContext context, argument_expression_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     assignment_expression returns assignment_expression
	 *
	 * Constraint:
	 *     (
	 *         conditional_expression=conditional_expression | 
	 *         (unary_expression=unary_expression assignment_operator=assignment_operator assignment_expression=assignment_expression)
	 *     )
	 */
	protected void sequence_assignment_expression(ISerializationContext context, assignment_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     assignment_operator returns assignment_operator
	 *
	 * Constraint:
	 *     (
	 *         mul_assign=MUL_ASSIGN | 
	 *         div_assign=DIV_ASSIGN | 
	 *         mod_assign=MOD_ASSIGN | 
	 *         add_assign=ADD_ASSIGN | 
	 *         sub_assign=SUB_ASSIGN | 
	 *         left_assign=LEFT_ASSIGN | 
	 *         right_assign=RIGHT_ASSIGN | 
	 *         and_assign=AND_ASSIGN | 
	 *         xor_assign=XOR_ASSIGN | 
	 *         or_assign=OR_ASSIGN
	 *     )
	 */
	protected void sequence_assignment_operator(ISerializationContext context, assignment_operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns booleanType
	 *     atomic2 returns booleanType
	 *     multiplicative_expression returns booleanType
	 *     multiplicative_expression.MUL_1_0 returns booleanType
	 *     additive_expression returns booleanType
	 *     additive_expression.ADD_1_0_0_0 returns booleanType
	 *     additive_expression.MINUS_1_0_1_0 returns booleanType
	 *     shift_expression returns booleanType
	 *     shift_expression.SHF_1_0 returns booleanType
	 *     relational_expression returns booleanType
	 *     relational_expression.REL_1_0 returns booleanType
	 *     equality_expression returns booleanType
	 *     equality_expression.EQL_1_0 returns booleanType
	 *     and_expression returns booleanType
	 *     and_expression.AND_1_0 returns booleanType
	 *     exclusive_or_expression returns booleanType
	 *     exclusive_or_expression.EXC_OR_1_0 returns booleanType
	 *     inclusive_or_expression returns booleanType
	 *     inclusive_or_expression.INC_OR_1_0 returns booleanType
	 *     logical_and_expression returns booleanType
	 *     logical_and_expression.LOG_AND_1_0 returns booleanType
	 *     logical_or_expression returns booleanType
	 *     logical_or_expression.LOG_OR_1_0 returns booleanType
	 *     simple_expression returns booleanType
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_atomic2(ISerializationContext context, booleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns floatType
	 *     atomic2 returns floatType
	 *     multiplicative_expression returns floatType
	 *     multiplicative_expression.MUL_1_0 returns floatType
	 *     additive_expression returns floatType
	 *     additive_expression.ADD_1_0_0_0 returns floatType
	 *     additive_expression.MINUS_1_0_1_0 returns floatType
	 *     shift_expression returns floatType
	 *     shift_expression.SHF_1_0 returns floatType
	 *     relational_expression returns floatType
	 *     relational_expression.REL_1_0 returns floatType
	 *     equality_expression returns floatType
	 *     equality_expression.EQL_1_0 returns floatType
	 *     and_expression returns floatType
	 *     and_expression.AND_1_0 returns floatType
	 *     exclusive_or_expression returns floatType
	 *     exclusive_or_expression.EXC_OR_1_0 returns floatType
	 *     inclusive_or_expression returns floatType
	 *     inclusive_or_expression.INC_OR_1_0 returns floatType
	 *     logical_and_expression returns floatType
	 *     logical_and_expression.LOG_AND_1_0 returns floatType
	 *     logical_or_expression returns floatType
	 *     logical_or_expression.LOG_OR_1_0 returns floatType
	 *     simple_expression returns floatType
	 *
	 * Constraint:
	 *     value=F_CONSTANT
	 */
	protected void sequence_atomic2(ISerializationContext context, floatType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FLOAT_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FLOAT_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomic2Access().getValueF_CONSTANTTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns intType
	 *     atomic2 returns intType
	 *     multiplicative_expression returns intType
	 *     multiplicative_expression.MUL_1_0 returns intType
	 *     additive_expression returns intType
	 *     additive_expression.ADD_1_0_0_0 returns intType
	 *     additive_expression.MINUS_1_0_1_0 returns intType
	 *     shift_expression returns intType
	 *     shift_expression.SHF_1_0 returns intType
	 *     relational_expression returns intType
	 *     relational_expression.REL_1_0 returns intType
	 *     equality_expression returns intType
	 *     equality_expression.EQL_1_0 returns intType
	 *     and_expression returns intType
	 *     and_expression.AND_1_0 returns intType
	 *     exclusive_or_expression returns intType
	 *     exclusive_or_expression.EXC_OR_1_0 returns intType
	 *     inclusive_or_expression returns intType
	 *     inclusive_or_expression.INC_OR_1_0 returns intType
	 *     logical_and_expression returns intType
	 *     logical_and_expression.LOG_AND_1_0 returns intType
	 *     logical_or_expression returns intType
	 *     logical_or_expression.LOG_OR_1_0 returns intType
	 *     simple_expression returns intType
	 *
	 * Constraint:
	 *     value=I_CONSTANT
	 */
	protected void sequence_atomic2(ISerializationContext context, intType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INT_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INT_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomic2Access().getValueI_CONSTANTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns stringType
	 *     atomic2 returns stringType
	 *     multiplicative_expression returns stringType
	 *     multiplicative_expression.MUL_1_0 returns stringType
	 *     additive_expression returns stringType
	 *     additive_expression.ADD_1_0_0_0 returns stringType
	 *     additive_expression.MINUS_1_0_1_0 returns stringType
	 *     shift_expression returns stringType
	 *     shift_expression.SHF_1_0 returns stringType
	 *     relational_expression returns stringType
	 *     relational_expression.REL_1_0 returns stringType
	 *     equality_expression returns stringType
	 *     equality_expression.EQL_1_0 returns stringType
	 *     and_expression returns stringType
	 *     and_expression.AND_1_0 returns stringType
	 *     exclusive_or_expression returns stringType
	 *     exclusive_or_expression.EXC_OR_1_0 returns stringType
	 *     inclusive_or_expression returns stringType
	 *     inclusive_or_expression.INC_OR_1_0 returns stringType
	 *     logical_and_expression returns stringType
	 *     logical_and_expression.LOG_AND_1_0 returns stringType
	 *     logical_or_expression returns stringType
	 *     logical_or_expression.LOG_OR_1_0 returns stringType
	 *     simple_expression returns stringType
	 *
	 * Constraint:
	 *     value=string_nova
	 */
	protected void sequence_atomic2(ISerializationContext context, stringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRING_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRING_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomic2Access().getValueString_novaParserRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns variableRef
	 *     atomic2 returns variableRef
	 *     multiplicative_expression returns variableRef
	 *     multiplicative_expression.MUL_1_0 returns variableRef
	 *     additive_expression returns variableRef
	 *     additive_expression.ADD_1_0_0_0 returns variableRef
	 *     additive_expression.MINUS_1_0_1_0 returns variableRef
	 *     shift_expression returns variableRef
	 *     shift_expression.SHF_1_0 returns variableRef
	 *     relational_expression returns variableRef
	 *     relational_expression.REL_1_0 returns variableRef
	 *     equality_expression returns variableRef
	 *     equality_expression.EQL_1_0 returns variableRef
	 *     and_expression returns variableRef
	 *     and_expression.AND_1_0 returns variableRef
	 *     exclusive_or_expression returns variableRef
	 *     exclusive_or_expression.EXC_OR_1_0 returns variableRef
	 *     inclusive_or_expression returns variableRef
	 *     inclusive_or_expression.INC_OR_1_0 returns variableRef
	 *     logical_and_expression returns variableRef
	 *     logical_and_expression.LOG_AND_1_0 returns variableRef
	 *     logical_or_expression returns variableRef
	 *     logical_or_expression.LOG_OR_1_0 returns variableRef
	 *     simple_expression returns variableRef
	 *
	 * Constraint:
	 *     variable=[direct_declarator|ID]
	 */
	protected void sequence_atomic2(ISerializationContext context, variableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomic2Access().getVariableDirect_declaratorIDTerminalRuleCall_0_1_0_1(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     atomic_type_specifier returns atomic_type_specifier
	 *
	 * Constraint:
	 *     (atomic=ATOMIC type_name=type_name)
	 */
	protected void sequence_atomic_type_specifier(ISerializationContext context, atomic_type_specifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_TYPE_SPECIFIER__ATOMIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_TYPE_SPECIFIER__ATOMIC));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_TYPE_SPECIFIER__TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_TYPE_SPECIFIER__TYPE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomic_type_specifierAccess().getAtomicATOMICParserRuleCall_0_0(), semanticObject.getAtomic());
		feeder.accept(grammarAccess.getAtomic_type_specifierAccess().getType_nameType_nameParserRuleCall_2_0(), semanticObject.getType_name());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     block_item returns block_item
	 *
	 * Constraint:
	 *     (declaration=declaration | statement=statement)
	 */
	protected void sequence_block_item(ISerializationContext context, block_item semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cast_expression returns simple_expression
	 *
	 * Constraint:
	 *     (type_name=type_name cast_expression=cast_expression)
	 */
	protected void sequence_cast_expression(ISerializationContext context, simple_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SIMPLE_EXPRESSION__TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SIMPLE_EXPRESSION__TYPE_NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SIMPLE_EXPRESSION__CAST_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SIMPLE_EXPRESSION__CAST_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCast_expressionAccess().getType_nameType_nameParserRuleCall_1_1_0(), semanticObject.getType_name());
		feeder.accept(grammarAccess.getCast_expressionAccess().getCast_expressionCast_expressionParserRuleCall_1_3_0(), semanticObject.getCast_expression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     compound_statement returns compound_statement
	 *
	 * Constraint:
	 *     block_item_list+=block_item+
	 */
	protected void sequence_compound_statement(ISerializationContext context, compound_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     conditional_expression returns conditional_expression
	 *
	 * Constraint:
	 *     (
	 *         simple_expression=simple_expression | 
	 *         (logical_or_expression=logical_or_expression expression=expression conditional_expression=conditional_expression)
	 *     )
	 */
	protected void sequence_conditional_expression(ISerializationContext context, conditional_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant returns constant
	 *
	 * Constraint:
	 *     (i_constant=I_CONSTANT | f_constant=F_CONSTANT | enumt=ENUM)
	 */
	protected void sequence_constant(ISerializationContext context, constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant_expression returns constant_expression
	 *
	 * Constraint:
	 *     conditional_expression=conditional_expression
	 */
	protected void sequence_constant_expression(ISerializationContext context, constant_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONSTANT_EXPRESSION__CONDITIONAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONSTANT_EXPRESSION__CONDITIONAL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstant_expressionAccess().getConditional_expressionConditional_expressionParserRuleCall_0(), semanticObject.getConditional_expression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declaration returns declaration
	 *
	 * Constraint:
	 *     (
	 *         declaration_specifiers=declaration_specifiers | 
	 *         (declaration_specifiers=declaration_specifiers init_declarator_list=init_declarator_list) | 
	 *         static_assert_declaration=static_assert_declaration
	 *     )
	 */
	protected void sequence_declaration(ISerializationContext context, declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declaration_list2 returns declaration_list2
	 *
	 * Constraint:
	 *     (declaration=declaration declaration_list2=declaration_list2)?
	 */
	protected void sequence_declaration_list2(ISerializationContext context, declaration_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declaration_list returns declaration_list
	 *
	 * Constraint:
	 *     (declaration=declaration declaration_list_2=declaration_list2)
	 */
	protected void sequence_declaration_list(ISerializationContext context, declaration_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION_LIST_2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION_LIST_2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaration_listAccess().getDeclarationDeclarationParserRuleCall_0_0(), semanticObject.getDeclaration());
		feeder.accept(grammarAccess.getDeclaration_listAccess().getDeclaration_list_2Declaration_list2ParserRuleCall_1_0(), semanticObject.getDeclaration_list_2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declaration_specifiers returns declaration_specifiers
	 *
	 * Constraint:
	 *     (
	 *         (storage_class_specifier=storage_class_specifier declaration_specifiers=declaration_specifiers) | 
	 *         storage_class_specifier=storage_class_specifier | 
	 *         (type_specifier=type_specifier declaration_specifiers=declaration_specifiers) | 
	 *         type_specifier=type_specifier | 
	 *         (type_qualifier=type_qualifier declaration_specifiers=declaration_specifiers) | 
	 *         type_qualifier=type_qualifier | 
	 *         (function_specifier=function_specifier declaration_specifiers=declaration_specifiers) | 
	 *         function_specifier=function_specifier | 
	 *         (alignment_specifier=alignment_specifier declaration_specifiers=declaration_specifiers) | 
	 *         alignment_specifier=alignment_specifier
	 *     )
	 */
	protected void sequence_declaration_specifiers(ISerializationContext context, declaration_specifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declarator returns declarator
	 *
	 * Constraint:
	 *     ((pointer=pointer direct_declarator=direct_declarator) | direct_declarator=direct_declarator)
	 */
	protected void sequence_declarator(ISerializationContext context, declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designation returns designation
	 *
	 * Constraint:
	 *     designator_list=designator_list
	 */
	protected void sequence_designation(ISerializationContext context, designation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DESIGNATION__DESIGNATOR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DESIGNATION__DESIGNATOR_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDesignationAccess().getDesignator_listDesignator_listParserRuleCall_0_0(), semanticObject.getDesignator_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     designator returns designator
	 *
	 * Constraint:
	 *     (constant_expression=constant_expression | identifier=ID)
	 */
	protected void sequence_designator(ISerializationContext context, designator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designator_list2 returns designator_list2
	 *
	 * Constraint:
	 *     (designator=designator designator_list2=designator_list2)?
	 */
	protected void sequence_designator_list2(ISerializationContext context, designator_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designator_list returns designator_list
	 *
	 * Constraint:
	 *     (designator=designator designator_list2=designator_list2)
	 */
	protected void sequence_designator_list(ISerializationContext context, designator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDesignator_listAccess().getDesignatorDesignatorParserRuleCall_0_0(), semanticObject.getDesignator());
		feeder.accept(grammarAccess.getDesignator_listAccess().getDesignator_list2Designator_list2ParserRuleCall_1_0(), semanticObject.getDesignator_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     direct_abstract_declarator2 returns direct_abstract_declarator2
	 *
	 * Constraint:
	 *     (
	 *         (static=STATIC type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *         (static=STATIC assignment_expression=assignment_expression) | 
	 *         (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *         (type_qualifier_list=type_qualifier_list static=STATIC assignment_expression=assignment_expression) | 
	 *         type_qualifier_list=type_qualifier_list | 
	 *         assignment_expression=assignment_expression | 
	 *         parameter_type_list=parameter_type_list
	 *     )
	 */
	protected void sequence_direct_abstract_declarator2(ISerializationContext context, direct_abstract_declarator2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_abstract_declarator returns direct_abstract_declarator
	 *
	 * Constraint:
	 *     direct_abstract_declarator2+=direct_abstract_declarator2+
	 */
	protected void sequence_direct_abstract_declarator(ISerializationContext context, direct_abstract_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_declarator2 returns direct_declarator2
	 *
	 * Constraint:
	 *     (
	 *         (static=STATIC type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *         (static=STATIC assignment_expression=assignment_expression) | 
	 *         type_qualifier_list=type_qualifier_list | 
	 *         (type_qualifier_list=type_qualifier_list static=STATIC assignment_expression=assignment_expression) | 
	 *         (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression) | 
	 *         type_qualifier_list=type_qualifier_list | 
	 *         assignment_expression=assignment_expression | 
	 *         parameter_type_list=parameter_type_list | 
	 *         identifier_list=identifier_list
	 *     )
	 */
	protected void sequence_direct_declarator2(ISerializationContext context, direct_declarator2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_declarator returns direct_declarator
	 *
	 * Constraint:
	 *     ((name=ID direct_declarators+=direct_declarator2*) | (Declarator=declarator direct_declarators+=direct_declarator2*))
	 */
	protected void sequence_direct_declarator(ISerializationContext context, direct_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     enum_specifier returns enum_specifier
	 *
	 * Constraint:
	 *     (
	 *         (enumt=ENUM enumerator_list=enumerator_list) | 
	 *         (enumt=ENUM enumerator_list=enumerator_list) | 
	 *         (enumt=ENUM identifier=ID enumerator_list=enumerator_list) | 
	 *         (enumt=ENUM identifier=ID enumerator_list=enumerator_list) | 
	 *         (enumt=ENUM identifier=ID)
	 *     )
	 */
	protected void sequence_enum_specifier(ISerializationContext context, enum_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     enumeration_constant returns enumeration_constant
	 *
	 * Constraint:
	 *     identifier=ID
	 */
	protected void sequence_enumeration_constant(ISerializationContext context, enumeration_constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATION_CONSTANT__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATION_CONSTANT__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumeration_constantAccess().getIdentifierIDTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     enumerator returns enumerator
	 *
	 * Constraint:
	 *     ((enumeration_constant=enumeration_constant constant_expression=constant_expression) | enumeration_constant=enumeration_constant)
	 */
	protected void sequence_enumerator(ISerializationContext context, enumerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     enumerator_list2 returns enumerator_list2
	 *
	 * Constraint:
	 *     (enumerator=enumerator enumerator_list2=enumerator_list2)
	 */
	protected void sequence_enumerator_list2(ISerializationContext context, enumerator_list2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST2__ENUMERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST2__ENUMERATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST2__ENUMERATOR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST2__ENUMERATOR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerator_list2Access().getEnumeratorEnumeratorParserRuleCall_1_0(), semanticObject.getEnumerator());
		feeder.accept(grammarAccess.getEnumerator_list2Access().getEnumerator_list2Enumerator_list2ParserRuleCall_2_0(), semanticObject.getEnumerator_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     enumerator_list returns enumerator_list
	 *
	 * Constraint:
	 *     (enumerator=enumerator enumerator_list2=enumerator_list2)
	 */
	protected void sequence_enumerator_list(ISerializationContext context, enumerator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMERATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMERATOR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMERATOR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerator_listAccess().getEnumeratorEnumeratorParserRuleCall_0_0(), semanticObject.getEnumerator());
		feeder.accept(grammarAccess.getEnumerator_listAccess().getEnumerator_list2Enumerator_list2ParserRuleCall_1_0(), semanticObject.getEnumerator_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns EQL
	 *     multiplicative_expression returns EQL
	 *     multiplicative_expression.MUL_1_0 returns EQL
	 *     additive_expression returns EQL
	 *     additive_expression.ADD_1_0_0_0 returns EQL
	 *     additive_expression.MINUS_1_0_1_0 returns EQL
	 *     shift_expression returns EQL
	 *     shift_expression.SHF_1_0 returns EQL
	 *     relational_expression returns EQL
	 *     relational_expression.REL_1_0 returns EQL
	 *     equality_expression returns EQL
	 *     equality_expression.EQL_1_0 returns EQL
	 *     and_expression returns EQL
	 *     and_expression.AND_1_0 returns EQL
	 *     exclusive_or_expression returns EQL
	 *     exclusive_or_expression.EXC_OR_1_0 returns EQL
	 *     inclusive_or_expression returns EQL
	 *     inclusive_or_expression.INC_OR_1_0 returns EQL
	 *     logical_and_expression returns EQL
	 *     logical_and_expression.LOG_AND_1_0 returns EQL
	 *     logical_or_expression returns EQL
	 *     logical_or_expression.LOG_OR_1_0 returns EQL
	 *     simple_expression returns EQL
	 *
	 * Constraint:
	 *     (left=equality_expression_EQL_1_0 (op=EQ_OP | op=NE_OP) right=relational_expression)
	 */
	protected void sequence_equality_expression(ISerializationContext context, EQL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns EXC_OR
	 *     multiplicative_expression returns EXC_OR
	 *     multiplicative_expression.MUL_1_0 returns EXC_OR
	 *     additive_expression returns EXC_OR
	 *     additive_expression.ADD_1_0_0_0 returns EXC_OR
	 *     additive_expression.MINUS_1_0_1_0 returns EXC_OR
	 *     shift_expression returns EXC_OR
	 *     shift_expression.SHF_1_0 returns EXC_OR
	 *     relational_expression returns EXC_OR
	 *     relational_expression.REL_1_0 returns EXC_OR
	 *     equality_expression returns EXC_OR
	 *     equality_expression.EQL_1_0 returns EXC_OR
	 *     and_expression returns EXC_OR
	 *     and_expression.AND_1_0 returns EXC_OR
	 *     exclusive_or_expression returns EXC_OR
	 *     exclusive_or_expression.EXC_OR_1_0 returns EXC_OR
	 *     inclusive_or_expression returns EXC_OR
	 *     inclusive_or_expression.INC_OR_1_0 returns EXC_OR
	 *     logical_and_expression returns EXC_OR
	 *     logical_and_expression.LOG_AND_1_0 returns EXC_OR
	 *     logical_or_expression returns EXC_OR
	 *     logical_or_expression.LOG_OR_1_0 returns EXC_OR
	 *     simple_expression returns EXC_OR
	 *
	 * Constraint:
	 *     (left=exclusive_or_expression_EXC_OR_1_0 right=and_expression)
	 */
	protected void sequence_exclusive_or_expression(ISerializationContext context, EXC_OR semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXC_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXC_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXC_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXC_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExclusive_or_expressionAccess().getEXC_ORLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExclusive_or_expressionAccess().getRightAnd_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression2 returns expression2
	 *
	 * Constraint:
	 *     (assignment_expression=assignment_expression expression2=expression2)?
	 */
	protected void sequence_expression2(ISerializationContext context, expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expression2 returns expression
	 *     expression returns expression
	 *
	 * Constraint:
	 *     (assignment_expression=assignment_expression expression2=expression2)
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POSTFIX_EXPRESSION2__ASSIGNMENT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POSTFIX_EXPRESSION2__ASSIGNMENT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION__EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION__EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getAssignment_expressionAssignment_expressionParserRuleCall_0_0(), semanticObject.getAssignment_expression());
		feeder.accept(grammarAccess.getExpressionAccess().getExpression2Expression2ParserRuleCall_1_0(), semanticObject.getExpression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression_statement returns expression_statement
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_expression_statement(ISerializationContext context, expression_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression_statementAccess().getExpressionExpressionParserRuleCall_1_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     external_declaration returns external_declaration
	 *
	 * Constraint:
	 *     (function_definition=function_definition | declaration=declaration)
	 */
	protected void sequence_external_declaration(ISerializationContext context, external_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     function_definition returns function_definition
	 *
	 * Constraint:
	 *     (
	 *         (declaration_specifiers=declaration_specifiers declarator=declarator declaration_list=declaration_list compound_statement=compound_statement) | 
	 *         (declaration_specifiers=declaration_specifiers declarator=declarator compound_statement=compound_statement)
	 *     )
	 */
	protected void sequence_function_definition(ISerializationContext context, function_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     function_specifier returns function_specifier
	 *
	 * Constraint:
	 *     (inline=INLINE | noreturn=NORETURN)
	 */
	protected void sequence_function_specifier(ISerializationContext context, function_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     generic_assoc_list returns generic_assoc_list
	 *
	 * Constraint:
	 *     (generic_association=generic_association generic_list+=generic_association*)
	 */
	protected void sequence_generic_assoc_list(ISerializationContext context, generic_assoc_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     generic_association returns generic_association
	 *
	 * Constraint:
	 *     ((type_name=type_name assignment_expression=assignment_expression) | (default=DEFAULT assignment_expression=assignment_expression))
	 */
	protected void sequence_generic_association(ISerializationContext context, generic_association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     generic_selection returns generic_selection
	 *
	 * Constraint:
	 *     (generic=GENERIC assignment_expression=assignment_expression generic_assoc_list=generic_assoc_list)
	 */
	protected void sequence_generic_selection(ISerializationContext context, generic_selection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__GENERIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__GENERIC));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__ASSIGNMENT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__ASSIGNMENT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__GENERIC_ASSOC_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__GENERIC_ASSOC_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneric_selectionAccess().getGenericGENERICParserRuleCall_0_0(), semanticObject.getGeneric());
		feeder.accept(grammarAccess.getGeneric_selectionAccess().getAssignment_expressionAssignment_expressionParserRuleCall_2_0(), semanticObject.getAssignment_expression());
		feeder.accept(grammarAccess.getGeneric_selectionAccess().getGeneric_assoc_listGeneric_assoc_listParserRuleCall_4_0(), semanticObject.getGeneric_assoc_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     identifier_list2 returns identifier_list2
	 *
	 * Constraint:
	 *     (identifier=ID identifier_list2=identifier_list2)?
	 */
	protected void sequence_identifier_list2(ISerializationContext context, identifier_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     identifier_list returns identifier_list
	 *
	 * Constraint:
	 *     (identifier=ID identifier_list2=identifier_list2)
	 */
	protected void sequence_identifier_list(ISerializationContext context, identifier_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentifier_listAccess().getIdentifierIDTerminalRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getIdentifier_listAccess().getIdentifier_list2Identifier_list2ParserRuleCall_1_0(), semanticObject.getIdentifier_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns INC_OR
	 *     multiplicative_expression returns INC_OR
	 *     multiplicative_expression.MUL_1_0 returns INC_OR
	 *     additive_expression returns INC_OR
	 *     additive_expression.ADD_1_0_0_0 returns INC_OR
	 *     additive_expression.MINUS_1_0_1_0 returns INC_OR
	 *     shift_expression returns INC_OR
	 *     shift_expression.SHF_1_0 returns INC_OR
	 *     relational_expression returns INC_OR
	 *     relational_expression.REL_1_0 returns INC_OR
	 *     equality_expression returns INC_OR
	 *     equality_expression.EQL_1_0 returns INC_OR
	 *     and_expression returns INC_OR
	 *     and_expression.AND_1_0 returns INC_OR
	 *     exclusive_or_expression returns INC_OR
	 *     exclusive_or_expression.EXC_OR_1_0 returns INC_OR
	 *     inclusive_or_expression returns INC_OR
	 *     inclusive_or_expression.INC_OR_1_0 returns INC_OR
	 *     logical_and_expression returns INC_OR
	 *     logical_and_expression.LOG_AND_1_0 returns INC_OR
	 *     logical_or_expression returns INC_OR
	 *     logical_or_expression.LOG_OR_1_0 returns INC_OR
	 *     simple_expression returns INC_OR
	 *
	 * Constraint:
	 *     (left=inclusive_or_expression_INC_OR_1_0 right=exclusive_or_expression)
	 */
	protected void sequence_inclusive_or_expression(ISerializationContext context, INC_OR semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INC_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INC_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INC_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INC_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInclusive_or_expressionAccess().getINC_ORLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getInclusive_or_expressionAccess().getRightExclusive_or_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator returns init_declarator
	 *
	 * Constraint:
	 *     ((declarator=declarator initializer=simple_expression) | declarator=declarator)
	 */
	protected void sequence_init_declarator(ISerializationContext context, init_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator_list2 returns init_declarator_list2
	 *
	 * Constraint:
	 *     (init_declarator=init_declarator init_declarator_list2=init_declarator_list2)?
	 */
	protected void sequence_init_declarator_list2(ISerializationContext context, init_declarator_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator_list returns init_declarator_list
	 *
	 * Constraint:
	 *     (init_declarator=init_declarator init_declarator_list2=init_declarator_list2)
	 */
	protected void sequence_init_declarator_list(ISerializationContext context, init_declarator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInit_declarator_listAccess().getInit_declaratorInit_declaratorParserRuleCall_0_0(), semanticObject.getInit_declarator());
		feeder.accept(grammarAccess.getInit_declarator_listAccess().getInit_declarator_list2Init_declarator_list2ParserRuleCall_1_0(), semanticObject.getInit_declarator_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     initializer returns initializer
	 *
	 * Constraint:
	 *     (initializer_list=initializer_list | initializer_list=initializer_list | assignment_expression=assignment_expression)
	 */
	protected void sequence_initializer(ISerializationContext context, initializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initializer_list2 returns initializer_list2
	 *
	 * Constraint:
	 *     (
	 *         (designation=designation initializer=initializer initializer_list2=initializer_list2) | 
	 *         (initializer=initializer initializer_list2=initializer_list2)
	 *     )?
	 */
	protected void sequence_initializer_list2(ISerializationContext context, initializer_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initializer_list returns initializer_list
	 *
	 * Constraint:
	 *     (
	 *         (designation=designation initializer=initializer initializer_list2=initializer_list2) | 
	 *         (initializer=initializer initializer_list2=initializer_list2)
	 *     )
	 */
	protected void sequence_initializer_list(ISerializationContext context, initializer_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     iteration_statement returns iteration_statement
	 *
	 * Constraint:
	 *     (
	 *         (while=WHILE expression=expression statement=statement) | 
	 *         (do=DO statement=statement while=WHILE expression=expression) | 
	 *         (for=FOR expression_statement=expression_statement expression_statement2=expression_statement statement=statement) | 
	 *         (for=FOR expression_statement=expression_statement expression_statement2=expression_statement expression=expression statement=statement) | 
	 *         (for=FOR declaration=declaration expression_statement=expression_statement statement=statement) | 
	 *         (for=FOR declaration=declaration expression_statement=expression_statement expression=expression statement=statement)
	 *     )
	 */
	protected void sequence_iteration_statement(ISerializationContext context, iteration_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     jump_statement returns jump_statement
	 *
	 * Constraint:
	 *     ((goto=GOTO identifier=ID) | continue=CONTINUE | break=BREAK | return=RETURN | (return=RETURN expression=expression))
	 */
	protected void sequence_jump_statement(ISerializationContext context, jump_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     labeled_statement returns labeled_statement
	 *
	 * Constraint:
	 *     (
	 *         (identifier=ID statement=statement) | 
	 *         (case=CASE constant_expression=constant_expression statement=statement) | 
	 *         (default=DEFAULT statement=statement)
	 *     )
	 */
	protected void sequence_labeled_statement(ISerializationContext context, labeled_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns LOG_AND
	 *     multiplicative_expression returns LOG_AND
	 *     multiplicative_expression.MUL_1_0 returns LOG_AND
	 *     additive_expression returns LOG_AND
	 *     additive_expression.ADD_1_0_0_0 returns LOG_AND
	 *     additive_expression.MINUS_1_0_1_0 returns LOG_AND
	 *     shift_expression returns LOG_AND
	 *     shift_expression.SHF_1_0 returns LOG_AND
	 *     relational_expression returns LOG_AND
	 *     relational_expression.REL_1_0 returns LOG_AND
	 *     equality_expression returns LOG_AND
	 *     equality_expression.EQL_1_0 returns LOG_AND
	 *     and_expression returns LOG_AND
	 *     and_expression.AND_1_0 returns LOG_AND
	 *     exclusive_or_expression returns LOG_AND
	 *     exclusive_or_expression.EXC_OR_1_0 returns LOG_AND
	 *     inclusive_or_expression returns LOG_AND
	 *     inclusive_or_expression.INC_OR_1_0 returns LOG_AND
	 *     logical_and_expression returns LOG_AND
	 *     logical_and_expression.LOG_AND_1_0 returns LOG_AND
	 *     logical_or_expression returns LOG_AND
	 *     logical_or_expression.LOG_OR_1_0 returns LOG_AND
	 *     simple_expression returns LOG_AND
	 *
	 * Constraint:
	 *     (left=logical_and_expression_LOG_AND_1_0 right=inclusive_or_expression)
	 */
	protected void sequence_logical_and_expression(ISerializationContext context, LOG_AND semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOG_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOG_AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOG_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOG_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogical_and_expressionAccess().getLOG_ANDLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogical_and_expressionAccess().getRightInclusive_or_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns LOG_OR
	 *     multiplicative_expression returns LOG_OR
	 *     multiplicative_expression.MUL_1_0 returns LOG_OR
	 *     additive_expression returns LOG_OR
	 *     additive_expression.ADD_1_0_0_0 returns LOG_OR
	 *     additive_expression.MINUS_1_0_1_0 returns LOG_OR
	 *     shift_expression returns LOG_OR
	 *     shift_expression.SHF_1_0 returns LOG_OR
	 *     relational_expression returns LOG_OR
	 *     relational_expression.REL_1_0 returns LOG_OR
	 *     equality_expression returns LOG_OR
	 *     equality_expression.EQL_1_0 returns LOG_OR
	 *     and_expression returns LOG_OR
	 *     and_expression.AND_1_0 returns LOG_OR
	 *     exclusive_or_expression returns LOG_OR
	 *     exclusive_or_expression.EXC_OR_1_0 returns LOG_OR
	 *     inclusive_or_expression returns LOG_OR
	 *     inclusive_or_expression.INC_OR_1_0 returns LOG_OR
	 *     logical_and_expression returns LOG_OR
	 *     logical_and_expression.LOG_AND_1_0 returns LOG_OR
	 *     logical_or_expression returns LOG_OR
	 *     logical_or_expression.LOG_OR_1_0 returns LOG_OR
	 *     simple_expression returns LOG_OR
	 *
	 * Constraint:
	 *     (left=logical_or_expression_LOG_OR_1_0 right=logical_and_expression)
	 */
	protected void sequence_logical_or_expression(ISerializationContext context, LOG_OR semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOG_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOG_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOG_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOG_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogical_or_expressionAccess().getLOG_ORLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogical_or_expressionAccess().getRightLogical_and_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns MUL
	 *     multiplicative_expression returns MUL
	 *     multiplicative_expression.MUL_1_0 returns MUL
	 *     additive_expression returns MUL
	 *     additive_expression.ADD_1_0_0_0 returns MUL
	 *     additive_expression.MINUS_1_0_1_0 returns MUL
	 *     shift_expression returns MUL
	 *     shift_expression.SHF_1_0 returns MUL
	 *     relational_expression returns MUL
	 *     relational_expression.REL_1_0 returns MUL
	 *     equality_expression returns MUL
	 *     equality_expression.EQL_1_0 returns MUL
	 *     and_expression returns MUL
	 *     and_expression.AND_1_0 returns MUL
	 *     exclusive_or_expression returns MUL
	 *     exclusive_or_expression.EXC_OR_1_0 returns MUL
	 *     inclusive_or_expression returns MUL
	 *     inclusive_or_expression.INC_OR_1_0 returns MUL
	 *     logical_and_expression returns MUL
	 *     logical_and_expression.LOG_AND_1_0 returns MUL
	 *     logical_or_expression returns MUL
	 *     logical_or_expression.LOG_OR_1_0 returns MUL
	 *     simple_expression returns MUL
	 *
	 * Constraint:
	 *     (left=multiplicative_expression_MUL_1_0 op=MUL_OP right=primary_expression)
	 */
	protected void sequence_multiplicative_expression(ISerializationContext context, MUL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MUL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MUL__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MUL__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MUL__OP));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MUL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MUL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicative_expressionAccess().getMULLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicative_expressionAccess().getOpMUL_OPParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMultiplicative_expressionAccess().getRightPrimary_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameter_declaration returns parameter_declaration
	 *
	 * Constraint:
	 *     (
	 *         (declaration_specifiers=declaration_specifiers declarator=declarator) | 
	 *         (declaration_specifiers=declaration_specifiers abstract_declarator=abstract_declarator) | 
	 *         declaration_specifiers=declaration_specifiers
	 *     )
	 */
	protected void sequence_parameter_declaration(ISerializationContext context, parameter_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_list2 returns parameter_list2
	 *
	 * Constraint:
	 *     (parameter_declaration=parameter_declaration parameter_list2=parameter_list2)?
	 */
	protected void sequence_parameter_list2(ISerializationContext context, parameter_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_list returns parameter_list
	 *
	 * Constraint:
	 *     (parameter_declaration=parameter_declaration parameter_list2=parameter_list2)
	 */
	protected void sequence_parameter_list(ISerializationContext context, parameter_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PARAMETER_LIST__PARAMETER_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PARAMETER_LIST__PARAMETER_DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PARAMETER_LIST__PARAMETER_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PARAMETER_LIST__PARAMETER_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameter_listAccess().getParameter_declarationParameter_declarationParserRuleCall_0_0(), semanticObject.getParameter_declaration());
		feeder.accept(grammarAccess.getParameter_listAccess().getParameter_list2Parameter_list2ParserRuleCall_1_0(), semanticObject.getParameter_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameter_type_list returns parameter_type_list
	 *
	 * Constraint:
	 *     ((parameter_list=parameter_list ellipsis=ELLIPSIS) | parameter_list=parameter_list)
	 */
	protected void sequence_parameter_type_list(ISerializationContext context, parameter_type_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     pointer returns pointer
	 *
	 * Constraint:
	 *     ((type_qualifier_list=type_qualifier_list pointer=pointer) | type_qualifier_list=type_qualifier_list | pointer=pointer)
	 */
	protected void sequence_pointer(ISerializationContext context, pointer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expression returns postfix_expression
	 *
	 * Constraint:
	 *     (
	 *         (primary_expression=primary_expression postifx_expres+=postfix_expression2*) | 
	 *         (type_name=type_name initializer_list=initializer_list postifx_expres+=postfix_expression2*) | 
	 *         (type_name=type_name initializer_list=initializer_list postifx_expres+=postfix_expression2*)
	 *     )
	 */
	protected void sequence_postfix_expression(ISerializationContext context, postfix_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns REL
	 *     multiplicative_expression returns REL
	 *     multiplicative_expression.MUL_1_0 returns REL
	 *     additive_expression returns REL
	 *     additive_expression.ADD_1_0_0_0 returns REL
	 *     additive_expression.MINUS_1_0_1_0 returns REL
	 *     shift_expression returns REL
	 *     shift_expression.SHF_1_0 returns REL
	 *     relational_expression returns REL
	 *     relational_expression.REL_1_0 returns REL
	 *     equality_expression returns REL
	 *     equality_expression.EQL_1_0 returns REL
	 *     and_expression returns REL
	 *     and_expression.AND_1_0 returns REL
	 *     exclusive_or_expression returns REL
	 *     exclusive_or_expression.EXC_OR_1_0 returns REL
	 *     inclusive_or_expression returns REL
	 *     inclusive_or_expression.INC_OR_1_0 returns REL
	 *     logical_and_expression returns REL
	 *     logical_and_expression.LOG_AND_1_0 returns REL
	 *     logical_or_expression returns REL
	 *     logical_or_expression.LOG_OR_1_0 returns REL
	 *     simple_expression returns REL
	 *
	 * Constraint:
	 *     (left=relational_expression_REL_1_0 op=relational_op right=shift_expression)
	 */
	protected void sequence_relational_expression(ISerializationContext context, REL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REL__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REL__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REL__OP));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelational_expressionAccess().getRELLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelational_expressionAccess().getOpRelational_opParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getRelational_expressionAccess().getRightShift_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     selection_statement returns selection_statement
	 *
	 * Constraint:
	 *     (
	 *         (if=IF expression=expression statement=statement else=ELSE statement2=statement) | 
	 *         (if=IF expression=expression statement=statement) | 
	 *         (switch=SWITCH expression=expression statement=statement)
	 *     )
	 */
	protected void sequence_selection_statement(ISerializationContext context, selection_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns SHF
	 *     multiplicative_expression returns SHF
	 *     multiplicative_expression.MUL_1_0 returns SHF
	 *     additive_expression returns SHF
	 *     additive_expression.ADD_1_0_0_0 returns SHF
	 *     additive_expression.MINUS_1_0_1_0 returns SHF
	 *     shift_expression returns SHF
	 *     shift_expression.SHF_1_0 returns SHF
	 *     relational_expression returns SHF
	 *     relational_expression.REL_1_0 returns SHF
	 *     equality_expression returns SHF
	 *     equality_expression.EQL_1_0 returns SHF
	 *     and_expression returns SHF
	 *     and_expression.AND_1_0 returns SHF
	 *     exclusive_or_expression returns SHF
	 *     exclusive_or_expression.EXC_OR_1_0 returns SHF
	 *     inclusive_or_expression returns SHF
	 *     inclusive_or_expression.INC_OR_1_0 returns SHF
	 *     logical_and_expression returns SHF
	 *     logical_and_expression.LOG_AND_1_0 returns SHF
	 *     logical_or_expression returns SHF
	 *     logical_or_expression.LOG_OR_1_0 returns SHF
	 *     simple_expression returns SHF
	 *
	 * Constraint:
	 *     (left=shift_expression_SHF_1_0 op=shift_op right=additive_expression)
	 */
	protected void sequence_shift_expression(ISerializationContext context, SHF semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHF__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHF__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHF__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHF__OP));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHF__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHF__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShift_expressionAccess().getSHFLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getShift_expressionAccess().getOpShift_opParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getShift_expressionAccess().getRightAdditive_expressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     specifier_qualifier_list returns specifier_qualifier_list
	 *
	 * Constraint:
	 *     (
	 *         (type_specifier=type_specifier specifier_qualifier_list=specifier_qualifier_list) | 
	 *         type_specifier=type_specifier | 
	 *         (type_qualifier=type_specifier specifier_qualifier_list=specifier_qualifier_list) | 
	 *         type_qualifier=type_specifier
	 *     )
	 */
	protected void sequence_specifier_qualifier_list(ISerializationContext context, specifier_qualifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     (
	 *         labeled_statement=labeled_statement | 
	 *         compound_statement=compound_statement | 
	 *         expression_statement=expression_statement | 
	 *         selection_statement=selection_statement | 
	 *         iteration_statement=iteration_statement | 
	 *         jump_statement=jump_statement
	 *     )
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     static_assert_declaration returns static_assert_declaration
	 *
	 * Constraint:
	 *     (static_assert=STATIC_ASSERT constant_expression=constant_expression string_literal=STRING_LITERAL)
	 */
	protected void sequence_static_assert_declaration(ISerializationContext context, static_assert_declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__STATIC_ASSERT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__STATIC_ASSERT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__CONSTANT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__CONSTANT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__STRING_LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__STRING_LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatic_assert_declarationAccess().getStatic_assertSTATIC_ASSERTParserRuleCall_0_0(), semanticObject.getStatic_assert());
		feeder.accept(grammarAccess.getStatic_assert_declarationAccess().getConstant_expressionConstant_expressionParserRuleCall_2_0(), semanticObject.getConstant_expression());
		feeder.accept(grammarAccess.getStatic_assert_declarationAccess().getString_literalSTRING_LITERALTerminalRuleCall_4_0(), semanticObject.getString_literal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     storage_class_specifier returns storage_class_specifier
	 *
	 * Constraint:
	 *     (
	 *         typedef=TYPEDEF | 
	 *         extern=EXTERN | 
	 *         static=STATIC | 
	 *         thread_local=THREAD_LOCAL | 
	 *         auto=AUTO | 
	 *         register=REGISTER
	 *     )
	 */
	protected void sequence_storage_class_specifier(ISerializationContext context, storage_class_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     string_nova returns string_nova
	 *
	 * Constraint:
	 *     (string_literal=STRING | func_name=FUNC_NAME)
	 */
	protected void sequence_string_nova(ISerializationContext context, string_nova semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration_list2 returns struct_declaration_list2
	 *
	 * Constraint:
	 *     (struct_declaration=struct_declaration struct_declaration_list2=struct_declaration_list2)
	 */
	protected void sequence_struct_declaration_list2(ISerializationContext context, struct_declaration_list2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST2__STRUCT_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST2__STRUCT_DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST2__STRUCT_DECLARATION_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST2__STRUCT_DECLARATION_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStruct_declaration_list2Access().getStruct_declarationStruct_declarationParserRuleCall_0_0(), semanticObject.getStruct_declaration());
		feeder.accept(grammarAccess.getStruct_declaration_list2Access().getStruct_declaration_list2Struct_declaration_list2ParserRuleCall_1_0(), semanticObject.getStruct_declaration_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration_list returns struct_declaration_list
	 *
	 * Constraint:
	 *     (struct_declaration=struct_declaration struct_declaration_list2=struct_declaration_list2)
	 */
	protected void sequence_struct_declaration_list(ISerializationContext context, struct_declaration_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStruct_declaration_listAccess().getStruct_declarationStruct_declarationParserRuleCall_0_0(), semanticObject.getStruct_declaration());
		feeder.accept(grammarAccess.getStruct_declaration_listAccess().getStruct_declaration_list2Struct_declaration_list2ParserRuleCall_1_0(), semanticObject.getStruct_declaration_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration returns struct_declaration
	 *
	 * Constraint:
	 *     (
	 *         specifier_qualifier_list=specifier_qualifier_list | 
	 *         (specifier_qualifier_list=specifier_qualifier_list struct_declarator_list=struct_declarator_list) | 
	 *         static_assert_declaration=static_assert_declaration
	 *     )
	 */
	protected void sequence_struct_declaration(ISerializationContext context, struct_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator_list2 returns struct_declarator_list2
	 *
	 * Constraint:
	 *     (struct_declarator=struct_declarator struct_declarator_list2=struct_declarator_list2)?
	 */
	protected void sequence_struct_declarator_list2(ISerializationContext context, struct_declarator_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator_list returns struct_declarator_list
	 *
	 * Constraint:
	 *     (struct_declarator=struct_declarator struct_declarator_list2=struct_declarator_list2)
	 */
	protected void sequence_struct_declarator_list(ISerializationContext context, struct_declarator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStruct_declarator_listAccess().getStruct_declaratorStruct_declaratorParserRuleCall_0_0(), semanticObject.getStruct_declarator());
		feeder.accept(grammarAccess.getStruct_declarator_listAccess().getStruct_declarator_list2Struct_declarator_list2ParserRuleCall_1_0(), semanticObject.getStruct_declarator_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator returns struct_declarator
	 *
	 * Constraint:
	 *     (constant_expression=constant_expression | (declarator=declarator constant_expression=constant_expression) | declarator=declarator)
	 */
	protected void sequence_struct_declarator(ISerializationContext context, struct_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_or_union_specifier returns struct_or_union_specifier
	 *
	 * Constraint:
	 *     (
	 *         (struct_or_union=struct_or_union struct_declaration_list=struct_declaration_list) | 
	 *         (struct_or_union=struct_or_union identifier=ID struct_declaration_list=struct_declaration_list)
	 *     )
	 */
	protected void sequence_struct_or_union_specifier(ISerializationContext context, struct_or_union_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_or_union returns struct_or_union
	 *
	 * Constraint:
	 *     (struct=STRUCT | union=UNION)
	 */
	protected void sequence_struct_or_union(ISerializationContext context, struct_or_union semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_or_union_specifier returns struct_or_union
	 *
	 * Constraint:
	 *     ((struct=STRUCT | union=UNION) identifier=ID)
	 */
	protected void sequence_struct_or_union_struct_or_union_specifier(ISerializationContext context, struct_or_union semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     translation_unit returns translation_unit
	 *
	 * Constraint:
	 *     external_declaration=external_declaration
	 */
	protected void sequence_translation_unit(ISerializationContext context, translation_unit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRANSLATION_UNIT__EXTERNAL_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRANSLATION_UNIT__EXTERNAL_DECLARATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTranslation_unitAccess().getExternal_declarationExternal_declarationParserRuleCall_0(), semanticObject.getExternal_declaration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_name returns type_name
	 *
	 * Constraint:
	 *     ((specifier_qualifier_list=specifier_qualifier_list abstract_declarator=abstract_declarator) | specifier_qualifier_list=specifier_qualifier_list)
	 */
	protected void sequence_type_name(ISerializationContext context, type_name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier_list2 returns type_qualifier_list2
	 *
	 * Constraint:
	 *     (type_qualifier=type_qualifier type_qualifier_list2=type_qualifier_list2)?
	 */
	protected void sequence_type_qualifier_list2(ISerializationContext context, type_qualifier_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier_list returns type_qualifier_list
	 *
	 * Constraint:
	 *     (type_qualifier=type_qualifier type_qualifier_list2=type_qualifier_list2)
	 */
	protected void sequence_type_qualifier_list(ISerializationContext context, type_qualifier_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_qualifier_listAccess().getType_qualifierType_qualifierParserRuleCall_0_0(), semanticObject.getType_qualifier());
		feeder.accept(grammarAccess.getType_qualifier_listAccess().getType_qualifier_list2Type_qualifier_list2ParserRuleCall_1_0(), semanticObject.getType_qualifier_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier returns type_qualifier
	 *
	 * Constraint:
	 *     (const=CONST | restrict=RESTRICT | volatile=VOLATILE | atomic=ATOMIC)
	 */
	protected void sequence_type_qualifier(ISerializationContext context, type_qualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns booleanType
	 *
	 * Constraint:
	 *     bool_type=BOOL
	 */
	protected void sequence_type_specifier(ISerializationContext context, booleanType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BOOLEAN_TYPE__BOOL_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BOOLEAN_TYPE__BOOL_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getBool_typeBOOLParserRuleCall_9_1_0(), semanticObject.getBool_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns charType
	 *
	 * Constraint:
	 *     char_type=CHAR
	 */
	protected void sequence_type_specifier(ISerializationContext context, charType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CHAR_TYPE__CHAR_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CHAR_TYPE__CHAR_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getChar_typeCHARParserRuleCall_1_1_0(), semanticObject.getChar_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns complexType
	 *
	 * Constraint:
	 *     complex_type=COMPLEX
	 */
	protected void sequence_type_specifier(ISerializationContext context, complexType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COMPLEX_TYPE__COMPLEX_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COMPLEX_TYPE__COMPLEX_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getComplex_typeCOMPLEXParserRuleCall_10_1_0(), semanticObject.getComplex_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns doubleType
	 *
	 * Constraint:
	 *     double_type=DOUBLE
	 */
	protected void sequence_type_specifier(ISerializationContext context, doubleType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DOUBLE_TYPE__DOUBLE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DOUBLE_TYPE__DOUBLE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getDouble_typeDOUBLEParserRuleCall_6_1_0(), semanticObject.getDouble_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns floatType
	 *
	 * Constraint:
	 *     float_type=FLOAT
	 */
	protected void sequence_type_specifier(ISerializationContext context, floatType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FLOAT_TYPE__FLOAT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FLOAT_TYPE__FLOAT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getFloat_typeFLOATParserRuleCall_5_1_0(), semanticObject.getFloat_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns imaginaryType
	 *
	 * Constraint:
	 *     imaginary_type=IMAGINARY
	 */
	protected void sequence_type_specifier(ISerializationContext context, imaginaryType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IMAGINARY_TYPE__IMAGINARY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IMAGINARY_TYPE__IMAGINARY_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getImaginary_typeIMAGINARYParserRuleCall_11_1_0(), semanticObject.getImaginary_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns intType
	 *
	 * Constraint:
	 *     int_type=INTNAME
	 */
	protected void sequence_type_specifier(ISerializationContext context, intType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INT_TYPE__INT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INT_TYPE__INT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getInt_typeINTNAMEParserRuleCall_3_1_0(), semanticObject.getInt_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns longType
	 *
	 * Constraint:
	 *     long_type=LONG
	 */
	protected void sequence_type_specifier(ISerializationContext context, longType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LONG_TYPE__LONG_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LONG_TYPE__LONG_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getLong_typeLONGParserRuleCall_4_1_0(), semanticObject.getLong_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns shortType
	 *
	 * Constraint:
	 *     short_type=SHORT
	 */
	protected void sequence_type_specifier(ISerializationContext context, shortType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHORT_TYPE__SHORT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHORT_TYPE__SHORT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getShort_typeSHORTParserRuleCall_2_1_0(), semanticObject.getShort_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns signedType
	 *
	 * Constraint:
	 *     signed_type=SIGNED
	 */
	protected void sequence_type_specifier(ISerializationContext context, signedType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SIGNED_TYPE__SIGNED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SIGNED_TYPE__SIGNED_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getSigned_typeSIGNEDParserRuleCall_7_1_0(), semanticObject.getSigned_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns type_specifier
	 *
	 * Constraint:
	 *     (
	 *         atomic_type_specifier=atomic_type_specifier | 
	 *         struct_or_union_specifier=struct_or_union_specifier | 
	 *         enum_specifier=enum_specifier | 
	 *         typedef_name=TYPEDEF
	 *     )
	 */
	protected void sequence_type_specifier(ISerializationContext context, type_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns unsignedType
	 *
	 * Constraint:
	 *     unsigned_type=UNSIGNED
	 */
	protected void sequence_type_specifier(ISerializationContext context, unsignedType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNSIGNED_TYPE__UNSIGNED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNSIGNED_TYPE__UNSIGNED_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getUnsigned_typeUNSIGNEDParserRuleCall_8_1_0(), semanticObject.getUnsigned_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns voidType
	 *
	 * Constraint:
	 *     void_type=VOID
	 */
	protected void sequence_type_specifier(ISerializationContext context, voidType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VOID_TYPE__VOID_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VOID_TYPE__VOID_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getVoid_typeVOIDParserRuleCall_0_1_0(), semanticObject.getVoid_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unary_expression returns unary_expression
	 *     cast_expression returns unary_expression
	 *
	 * Constraint:
	 *     (
	 *         postfix_expression=postfix_expression | 
	 *         (inc_op=INC_OP unary_expression=unary_expression) | 
	 *         (dec_op=DEC_OP unary_expression=unary_expression) | 
	 *         (unary_operator=unary_operator cast_expression=cast_expression) | 
	 *         (sizeof=SIZEOF unary_expression=unary_expression) | 
	 *         (sizeof=SIZEOF type_name=type_name) | 
	 *         (alignof=ALIGNOF type_name=type_name)
	 *     )
	 */
	protected void sequence_unary_expression(ISerializationContext context, unary_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
