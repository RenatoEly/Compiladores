/*
 * generated by Xtext 2.9.2
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.abstract_declarator;
import org.xtext.example.mydsl.myDsl.additive_expression;
import org.xtext.example.mydsl.myDsl.additive_expression2;
import org.xtext.example.mydsl.myDsl.alignment_specifier;
import org.xtext.example.mydsl.myDsl.and_expression;
import org.xtext.example.mydsl.myDsl.and_expression2;
import org.xtext.example.mydsl.myDsl.argument_expression_list;
import org.xtext.example.mydsl.myDsl.argument_expression_list2;
import org.xtext.example.mydsl.myDsl.assignment_expression;
import org.xtext.example.mydsl.myDsl.assignment_operator;
import org.xtext.example.mydsl.myDsl.atomic_type_specifier;
import org.xtext.example.mydsl.myDsl.block_item;
import org.xtext.example.mydsl.myDsl.cast_expression;
import org.xtext.example.mydsl.myDsl.compound_statement;
import org.xtext.example.mydsl.myDsl.conditional_expression;
import org.xtext.example.mydsl.myDsl.constant;
import org.xtext.example.mydsl.myDsl.constant_expression;
import org.xtext.example.mydsl.myDsl.declaration;
import org.xtext.example.mydsl.myDsl.declaration_list;
import org.xtext.example.mydsl.myDsl.declaration_list2;
import org.xtext.example.mydsl.myDsl.declaration_specifiers;
import org.xtext.example.mydsl.myDsl.declarator;
import org.xtext.example.mydsl.myDsl.designation;
import org.xtext.example.mydsl.myDsl.designator;
import org.xtext.example.mydsl.myDsl.designator_list;
import org.xtext.example.mydsl.myDsl.designator_list2;
import org.xtext.example.mydsl.myDsl.direct_abstract_declarator;
import org.xtext.example.mydsl.myDsl.direct_abstract_declarator2;
import org.xtext.example.mydsl.myDsl.direct_declarator;
import org.xtext.example.mydsl.myDsl.direct_declarator2;
import org.xtext.example.mydsl.myDsl.enum_specifier;
import org.xtext.example.mydsl.myDsl.enumeration_constant;
import org.xtext.example.mydsl.myDsl.enumerator;
import org.xtext.example.mydsl.myDsl.enumerator_list;
import org.xtext.example.mydsl.myDsl.enumerator_list2;
import org.xtext.example.mydsl.myDsl.equality_expression;
import org.xtext.example.mydsl.myDsl.equality_expression2;
import org.xtext.example.mydsl.myDsl.exclusive_or_expression;
import org.xtext.example.mydsl.myDsl.exclusive_or_expression2;
import org.xtext.example.mydsl.myDsl.expression;
import org.xtext.example.mydsl.myDsl.expression2;
import org.xtext.example.mydsl.myDsl.expression_statement;
import org.xtext.example.mydsl.myDsl.external_declaration;
import org.xtext.example.mydsl.myDsl.function_definition;
import org.xtext.example.mydsl.myDsl.function_specifier;
import org.xtext.example.mydsl.myDsl.generic_assoc_list;
import org.xtext.example.mydsl.myDsl.generic_assoc_list2;
import org.xtext.example.mydsl.myDsl.generic_association;
import org.xtext.example.mydsl.myDsl.generic_selection;
import org.xtext.example.mydsl.myDsl.identifier_list;
import org.xtext.example.mydsl.myDsl.identifier_list2;
import org.xtext.example.mydsl.myDsl.inclusive_or_expression;
import org.xtext.example.mydsl.myDsl.inclusive_or_expression2;
import org.xtext.example.mydsl.myDsl.init_declarator;
import org.xtext.example.mydsl.myDsl.init_declarator_list;
import org.xtext.example.mydsl.myDsl.init_declarator_list2;
import org.xtext.example.mydsl.myDsl.initializer;
import org.xtext.example.mydsl.myDsl.initializer_list;
import org.xtext.example.mydsl.myDsl.initializer_list2;
import org.xtext.example.mydsl.myDsl.integer;
import org.xtext.example.mydsl.myDsl.iteration_statement;
import org.xtext.example.mydsl.myDsl.jump_statement;
import org.xtext.example.mydsl.myDsl.labeled_statement;
import org.xtext.example.mydsl.myDsl.logical_and_expression;
import org.xtext.example.mydsl.myDsl.logical_and_expression2;
import org.xtext.example.mydsl.myDsl.logical_or_expression;
import org.xtext.example.mydsl.myDsl.logical_or_expression2;
import org.xtext.example.mydsl.myDsl.multiplicative_expression;
import org.xtext.example.mydsl.myDsl.multiplicative_expression2;
import org.xtext.example.mydsl.myDsl.parameter_declaration;
import org.xtext.example.mydsl.myDsl.parameter_list;
import org.xtext.example.mydsl.myDsl.parameter_list2;
import org.xtext.example.mydsl.myDsl.parameter_type_list;
import org.xtext.example.mydsl.myDsl.pointer;
import org.xtext.example.mydsl.myDsl.postfix_expression;
import org.xtext.example.mydsl.myDsl.postfix_expression2;
import org.xtext.example.mydsl.myDsl.primary_expression;
import org.xtext.example.mydsl.myDsl.relational_expression;
import org.xtext.example.mydsl.myDsl.relational_expression2;
import org.xtext.example.mydsl.myDsl.selection_statement;
import org.xtext.example.mydsl.myDsl.shift_expression;
import org.xtext.example.mydsl.myDsl.shift_expression2;
import org.xtext.example.mydsl.myDsl.specifier_qualifier_list;
import org.xtext.example.mydsl.myDsl.statement;
import org.xtext.example.mydsl.myDsl.static_assert_declaration;
import org.xtext.example.mydsl.myDsl.storage_class_specifier;
import org.xtext.example.mydsl.myDsl.string_nova;
import org.xtext.example.mydsl.myDsl.struct_declaration;
import org.xtext.example.mydsl.myDsl.struct_declaration_list;
import org.xtext.example.mydsl.myDsl.struct_declaration_list2;
import org.xtext.example.mydsl.myDsl.struct_declarator;
import org.xtext.example.mydsl.myDsl.struct_declarator_list;
import org.xtext.example.mydsl.myDsl.struct_declarator_list2;
import org.xtext.example.mydsl.myDsl.struct_or_union;
import org.xtext.example.mydsl.myDsl.struct_or_union_specifier;
import org.xtext.example.mydsl.myDsl.translation_unit;
import org.xtext.example.mydsl.myDsl.type_name;
import org.xtext.example.mydsl.myDsl.type_qualifier;
import org.xtext.example.mydsl.myDsl.type_qualifier_list;
import org.xtext.example.mydsl.myDsl.type_qualifier_list2;
import org.xtext.example.mydsl.myDsl.type_specifier;
import org.xtext.example.mydsl.myDsl.unary_expression;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.ABSTRACT_DECLARATOR:
				sequence_abstract_declarator(context, (abstract_declarator) semanticObject); 
				return; 
			case MyDslPackage.ADDITIVE_EXPRESSION:
				sequence_additive_expression(context, (additive_expression) semanticObject); 
				return; 
			case MyDslPackage.ADDITIVE_EXPRESSION2:
				sequence_additive_expression2(context, (additive_expression2) semanticObject); 
				return; 
			case MyDslPackage.ALIGNMENT_SPECIFIER:
				sequence_alignment_specifier(context, (alignment_specifier) semanticObject); 
				return; 
			case MyDslPackage.AND_EXPRESSION:
				sequence_and_expression(context, (and_expression) semanticObject); 
				return; 
			case MyDslPackage.AND_EXPRESSION2:
				sequence_and_expression2(context, (and_expression2) semanticObject); 
				return; 
			case MyDslPackage.ARGUMENT_EXPRESSION_LIST:
				sequence_argument_expression_list(context, (argument_expression_list) semanticObject); 
				return; 
			case MyDslPackage.ARGUMENT_EXPRESSION_LIST2:
				sequence_argument_expression_list2(context, (argument_expression_list2) semanticObject); 
				return; 
			case MyDslPackage.ASSIGNMENT_EXPRESSION:
				sequence_assignment_expression(context, (assignment_expression) semanticObject); 
				return; 
			case MyDslPackage.ASSIGNMENT_OPERATOR:
				sequence_assignment_operator(context, (assignment_operator) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_TYPE_SPECIFIER:
				sequence_atomic_type_specifier(context, (atomic_type_specifier) semanticObject); 
				return; 
			case MyDslPackage.BLOCK_ITEM:
				sequence_block_item(context, (block_item) semanticObject); 
				return; 
			case MyDslPackage.CAST_EXPRESSION:
				sequence_cast_expression(context, (cast_expression) semanticObject); 
				return; 
			case MyDslPackage.COMPOUND_STATEMENT:
				sequence_compound_statement(context, (compound_statement) semanticObject); 
				return; 
			case MyDslPackage.CONDITIONAL_EXPRESSION:
				sequence_conditional_expression(context, (conditional_expression) semanticObject); 
				return; 
			case MyDslPackage.CONSTANT:
				sequence_constant(context, (constant) semanticObject); 
				return; 
			case MyDslPackage.CONSTANT_EXPRESSION:
				sequence_constant_expression(context, (constant_expression) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION:
				sequence_declaration(context, (declaration) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_LIST:
				sequence_declaration_list(context, (declaration_list) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_LIST2:
				sequence_declaration_list2(context, (declaration_list2) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION_SPECIFIERS:
				sequence_declaration_specifiers(context, (declaration_specifiers) semanticObject); 
				return; 
			case MyDslPackage.DECLARATOR:
				sequence_declarator(context, (declarator) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATION:
				sequence_designation(context, (designation) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR:
				sequence_designator(context, (designator) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR_LIST:
				sequence_designator_list(context, (designator_list) semanticObject); 
				return; 
			case MyDslPackage.DESIGNATOR_LIST2:
				sequence_designator_list2(context, (designator_list2) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_ABSTRACT_DECLARATOR:
				sequence_direct_abstract_declarator(context, (direct_abstract_declarator) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_ABSTRACT_DECLARATOR2:
				sequence_direct_abstract_declarator2(context, (direct_abstract_declarator2) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_DECLARATOR:
				sequence_direct_declarator(context, (direct_declarator) semanticObject); 
				return; 
			case MyDslPackage.DIRECT_DECLARATOR2:
				sequence_direct_declarator2(context, (direct_declarator2) semanticObject); 
				return; 
			case MyDslPackage.ENUM_SPECIFIER:
				sequence_enum_specifier(context, (enum_specifier) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATION_CONSTANT:
				sequence_enumeration_constant(context, (enumeration_constant) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATOR:
				sequence_enumerator(context, (enumerator) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATOR_LIST:
				sequence_enumerator_list(context, (enumerator_list) semanticObject); 
				return; 
			case MyDslPackage.ENUMERATOR_LIST2:
				sequence_enumerator_list2(context, (enumerator_list2) semanticObject); 
				return; 
			case MyDslPackage.EQUALITY_EXPRESSION:
				sequence_equality_expression(context, (equality_expression) semanticObject); 
				return; 
			case MyDslPackage.EQUALITY_EXPRESSION2:
				sequence_equality_expression2(context, (equality_expression2) semanticObject); 
				return; 
			case MyDslPackage.EXCLUSIVE_OR_EXPRESSION:
				sequence_exclusive_or_expression(context, (exclusive_or_expression) semanticObject); 
				return; 
			case MyDslPackage.EXCLUSIVE_OR_EXPRESSION2:
				sequence_exclusive_or_expression2(context, (exclusive_or_expression2) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION2:
				sequence_expression2(context, (expression2) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION_STATEMENT:
				sequence_expression_statement(context, (expression_statement) semanticObject); 
				return; 
			case MyDslPackage.EXTERNAL_DECLARATION:
				sequence_external_declaration(context, (external_declaration) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_DEFINITION:
				sequence_function_definition(context, (function_definition) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_SPECIFIER:
				sequence_function_specifier(context, (function_specifier) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_ASSOC_LIST:
				sequence_generic_assoc_list(context, (generic_assoc_list) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_ASSOC_LIST2:
				sequence_generic_assoc_list2(context, (generic_assoc_list2) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_ASSOCIATION:
				sequence_generic_association(context, (generic_association) semanticObject); 
				return; 
			case MyDslPackage.GENERIC_SELECTION:
				sequence_generic_selection(context, (generic_selection) semanticObject); 
				return; 
			case MyDslPackage.IDENTIFIER_LIST:
				sequence_identifier_list(context, (identifier_list) semanticObject); 
				return; 
			case MyDslPackage.IDENTIFIER_LIST2:
				sequence_identifier_list2(context, (identifier_list2) semanticObject); 
				return; 
			case MyDslPackage.INCLUSIVE_OR_EXPRESSION:
				sequence_inclusive_or_expression(context, (inclusive_or_expression) semanticObject); 
				return; 
			case MyDslPackage.INCLUSIVE_OR_EXPRESSION2:
				sequence_inclusive_or_expression2(context, (inclusive_or_expression2) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR:
				sequence_init_declarator(context, (init_declarator) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR_LIST:
				sequence_init_declarator_list(context, (init_declarator_list) semanticObject); 
				return; 
			case MyDslPackage.INIT_DECLARATOR_LIST2:
				sequence_init_declarator_list2(context, (init_declarator_list2) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER:
				sequence_initializer(context, (initializer) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER_LIST:
				sequence_initializer_list(context, (initializer_list) semanticObject); 
				return; 
			case MyDslPackage.INITIALIZER_LIST2:
				sequence_initializer_list2(context, (initializer_list2) semanticObject); 
				return; 
			case MyDslPackage.INTEGER:
				sequence_type_specifier(context, (integer) semanticObject); 
				return; 
			case MyDslPackage.ITERATION_STATEMENT:
				sequence_iteration_statement(context, (iteration_statement) semanticObject); 
				return; 
			case MyDslPackage.JUMP_STATEMENT:
				sequence_jump_statement(context, (jump_statement) semanticObject); 
				return; 
			case MyDslPackage.LABELED_STATEMENT:
				sequence_labeled_statement(context, (labeled_statement) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_AND_EXPRESSION:
				sequence_logical_and_expression(context, (logical_and_expression) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_AND_EXPRESSION2:
				sequence_logical_and_expression2(context, (logical_and_expression2) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_OR_EXPRESSION:
				sequence_logical_or_expression(context, (logical_or_expression) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_OR_EXPRESSION2:
				sequence_logical_or_expression2(context, (logical_or_expression2) semanticObject); 
				return; 
			case MyDslPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_multiplicative_expression(context, (multiplicative_expression) semanticObject); 
				return; 
			case MyDslPackage.MULTIPLICATIVE_EXPRESSION2:
				sequence_multiplicative_expression2(context, (multiplicative_expression2) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_DECLARATION:
				sequence_parameter_declaration(context, (parameter_declaration) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_LIST:
				sequence_parameter_list(context, (parameter_list) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_LIST2:
				sequence_parameter_list2(context, (parameter_list2) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_TYPE_LIST:
				sequence_parameter_type_list(context, (parameter_type_list) semanticObject); 
				return; 
			case MyDslPackage.POINTER:
				sequence_pointer(context, (pointer) semanticObject); 
				return; 
			case MyDslPackage.POSTFIX_EXPRESSION:
				sequence_postfix_expression(context, (postfix_expression) semanticObject); 
				return; 
			case MyDslPackage.POSTFIX_EXPRESSION2:
				sequence_postfix_expression2(context, (postfix_expression2) semanticObject); 
				return; 
			case MyDslPackage.PRIMARY_EXPRESSION:
				sequence_primary_expression(context, (primary_expression) semanticObject); 
				return; 
			case MyDslPackage.RELATIONAL_EXPRESSION:
				sequence_relational_expression(context, (relational_expression) semanticObject); 
				return; 
			case MyDslPackage.RELATIONAL_EXPRESSION2:
				sequence_relational_expression2(context, (relational_expression2) semanticObject); 
				return; 
			case MyDslPackage.SELECTION_STATEMENT:
				sequence_selection_statement(context, (selection_statement) semanticObject); 
				return; 
			case MyDslPackage.SHIFT_EXPRESSION:
				sequence_shift_expression(context, (shift_expression) semanticObject); 
				return; 
			case MyDslPackage.SHIFT_EXPRESSION2:
				sequence_shift_expression2(context, (shift_expression2) semanticObject); 
				return; 
			case MyDslPackage.SPECIFIER_QUALIFIER_LIST:
				sequence_specifier_qualifier_list(context, (specifier_qualifier_list) semanticObject); 
				return; 
			case MyDslPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case MyDslPackage.STATIC_ASSERT_DECLARATION:
				sequence_static_assert_declaration(context, (static_assert_declaration) semanticObject); 
				return; 
			case MyDslPackage.STORAGE_CLASS_SPECIFIER:
				sequence_storage_class_specifier(context, (storage_class_specifier) semanticObject); 
				return; 
			case MyDslPackage.STRING_NOVA:
				sequence_string_nova(context, (string_nova) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION:
				sequence_struct_declaration(context, (struct_declaration) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION_LIST:
				sequence_struct_declaration_list(context, (struct_declaration_list) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATION_LIST2:
				sequence_struct_declaration_list2(context, (struct_declaration_list2) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR:
				sequence_struct_declarator(context, (struct_declarator) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR_LIST:
				sequence_struct_declarator_list(context, (struct_declarator_list) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_DECLARATOR_LIST2:
				sequence_struct_declarator_list2(context, (struct_declarator_list2) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_OR_UNION:
				if (rule == grammarAccess.getStruct_or_unionRule()) {
					sequence_struct_or_union(context, (struct_or_union) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStruct_or_union_specifierRule()) {
					sequence_struct_or_union_struct_or_union_specifier(context, (struct_or_union) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.STRUCT_OR_UNION_SPECIFIER:
				sequence_struct_or_union_specifier(context, (struct_or_union_specifier) semanticObject); 
				return; 
			case MyDslPackage.TRANSLATION_UNIT:
				sequence_translation_unit(context, (translation_unit) semanticObject); 
				return; 
			case MyDslPackage.TYPE_NAME:
				sequence_type_name(context, (type_name) semanticObject); 
				return; 
			case MyDslPackage.TYPE_QUALIFIER:
				sequence_type_qualifier(context, (type_qualifier) semanticObject); 
				return; 
			case MyDslPackage.TYPE_QUALIFIER_LIST:
				sequence_type_qualifier_list(context, (type_qualifier_list) semanticObject); 
				return; 
			case MyDslPackage.TYPE_QUALIFIER_LIST2:
				sequence_type_qualifier_list2(context, (type_qualifier_list2) semanticObject); 
				return; 
			case MyDslPackage.TYPE_SPECIFIER:
				sequence_type_specifier(context, (type_specifier) semanticObject); 
				return; 
			case MyDslPackage.UNARY_EXPRESSION:
				sequence_unary_expression(context, (unary_expression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     declaracoes+=translation_unit+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     abstract_declarator returns abstract_declarator
	 *
	 * Constraint:
	 *     ((pointer=pointer direct_abstract_declarator=direct_abstract_declarator) | pointer=pointer | direct_abstract_declarator=direct_abstract_declarator)
	 */
	protected void sequence_abstract_declarator(ISerializationContext context, abstract_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     additive_expression2 returns additive_expression2
	 *
	 * Constraint:
	 *     (
	 *         (multiplicative_expression=multiplicative_expression additive_expression2=additive_expression2) | 
	 *         (multiplicative_expression=multiplicative_expression additive_expression2=additive_expression2)
	 *     )?
	 */
	protected void sequence_additive_expression2(ISerializationContext context, additive_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     additive_expression returns additive_expression
	 *
	 * Constraint:
	 *     (multiplicative_expression=multiplicative_expression additive_expression2=additive_expression2)
	 */
	protected void sequence_additive_expression(ISerializationContext context, additive_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION__ADDITIVE_EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADDITIVE_EXPRESSION__ADDITIVE_EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditive_expressionAccess().getMultiplicative_expressionMultiplicative_expressionParserRuleCall_0_0(), semanticObject.getMultiplicative_expression());
		feeder.accept(grammarAccess.getAdditive_expressionAccess().getAdditive_expression2Additive_expression2ParserRuleCall_1_0(), semanticObject.getAdditive_expression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     alignment_specifier returns alignment_specifier
	 *
	 * Constraint:
	 *     ((alignas=ALIGNAS type_name=type_name) | (alignas=ALIGNAS constant_expression=constant_expression))
	 */
	protected void sequence_alignment_specifier(ISerializationContext context, alignment_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     and_expression2 returns and_expression2
	 *
	 * Constraint:
	 *     (equality_expression=equality_expression and_expression2=and_expression2)?
	 */
	protected void sequence_and_expression2(ISerializationContext context, and_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     and_expression returns and_expression
	 *
	 * Constraint:
	 *     (equality_expression=equality_expression and_expression2=and_expression2)
	 */
	protected void sequence_and_expression(ISerializationContext context, and_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND_EXPRESSION__EQUALITY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND_EXPRESSION__EQUALITY_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND_EXPRESSION__AND_EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND_EXPRESSION__AND_EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_expressionAccess().getEquality_expressionEquality_expressionParserRuleCall_0_0(), semanticObject.getEquality_expression());
		feeder.accept(grammarAccess.getAnd_expressionAccess().getAnd_expression2And_expression2ParserRuleCall_1_0(), semanticObject.getAnd_expression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     argument_expression_list2 returns argument_expression_list2
	 *
	 * Constraint:
	 *     (assignment_expression=assignment_expression argument_expression_list2=argument_expression_list2)
	 */
	protected void sequence_argument_expression_list2(ISerializationContext context, argument_expression_list2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ARGUMENT_EXPRESSION_LIST2__ASSIGNMENT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ARGUMENT_EXPRESSION_LIST2__ASSIGNMENT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ARGUMENT_EXPRESSION_LIST2__ARGUMENT_EXPRESSION_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ARGUMENT_EXPRESSION_LIST2__ARGUMENT_EXPRESSION_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgument_expression_list2Access().getAssignment_expressionAssignment_expressionParserRuleCall_1_0(), semanticObject.getAssignment_expression());
		feeder.accept(grammarAccess.getArgument_expression_list2Access().getArgument_expression_list2Argument_expression_list2ParserRuleCall_2_0(), semanticObject.getArgument_expression_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     argument_expression_list returns argument_expression_list
	 *
	 * Constraint:
	 *     (assignment_expression=assignment_expression argument_expression_list2=argument_expression_list2)
	 */
	protected void sequence_argument_expression_list(ISerializationContext context, argument_expression_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ARGUMENT_EXPRESSION_LIST__ASSIGNMENT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ARGUMENT_EXPRESSION_LIST__ASSIGNMENT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ARGUMENT_EXPRESSION_LIST__ARGUMENT_EXPRESSION_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ARGUMENT_EXPRESSION_LIST__ARGUMENT_EXPRESSION_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgument_expression_listAccess().getAssignment_expressionAssignment_expressionParserRuleCall_0_0(), semanticObject.getAssignment_expression());
		feeder.accept(grammarAccess.getArgument_expression_listAccess().getArgument_expression_list2Argument_expression_list2ParserRuleCall_1_0(), semanticObject.getArgument_expression_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     assignment_expression returns assignment_expression
	 *
	 * Constraint:
	 *     (
	 *         conditional_expression=conditional_expression | 
	 *         (unary_expression=unary_expression assignment_operator=assignment_operator assignment_expression=assignment_expression)
	 *     )
	 */
	protected void sequence_assignment_expression(ISerializationContext context, assignment_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     assignment_operator returns assignment_operator
	 *
	 * Constraint:
	 *     (
	 *         mul_assign=MUL_ASSIGN | 
	 *         div_assign=DIV_ASSIGN | 
	 *         mod_assign=MOD_ASSIGN | 
	 *         add_assign=ADD_ASSIGN | 
	 *         sub_assign=SUB_ASSIGN | 
	 *         left_assign=LEFT_ASSIGN | 
	 *         right_assign=RIGHT_ASSIGN | 
	 *         and_assign=AND_ASSIGN | 
	 *         xor_assign=XOR_ASSIGN | 
	 *         or_assign=OR_ASSIGN
	 *     )
	 */
	protected void sequence_assignment_operator(ISerializationContext context, assignment_operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     atomic_type_specifier returns atomic_type_specifier
	 *
	 * Constraint:
	 *     (atomic=ATOMIC type_name=type_name)
	 */
	protected void sequence_atomic_type_specifier(ISerializationContext context, atomic_type_specifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_TYPE_SPECIFIER__ATOMIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_TYPE_SPECIFIER__ATOMIC));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_TYPE_SPECIFIER__TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_TYPE_SPECIFIER__TYPE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomic_type_specifierAccess().getAtomicATOMICParserRuleCall_0_0(), semanticObject.getAtomic());
		feeder.accept(grammarAccess.getAtomic_type_specifierAccess().getType_nameType_nameParserRuleCall_2_0(), semanticObject.getType_name());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     block_item returns block_item
	 *
	 * Constraint:
	 *     (declaration=declaration | statement=statement)
	 */
	protected void sequence_block_item(ISerializationContext context, block_item semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cast_expression returns cast_expression
	 *
	 * Constraint:
	 *     (unary_expression=unary_expression | (type_name=type_name cast_expression=cast_expression))
	 */
	protected void sequence_cast_expression(ISerializationContext context, cast_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     compound_statement returns compound_statement
	 *
	 * Constraint:
	 *     block_item_list+=block_item+
	 */
	protected void sequence_compound_statement(ISerializationContext context, compound_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     conditional_expression returns conditional_expression
	 *
	 * Constraint:
	 *     (
	 *         logical_or_expression=logical_or_expression | 
	 *         (logical_or_expression=logical_or_expression expression=expression conditional_expression=conditional_expression)
	 *     )
	 */
	protected void sequence_conditional_expression(ISerializationContext context, conditional_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant returns constant
	 *
	 * Constraint:
	 *     (i_constant=I_CONSTANT | f_constant=F_CONSTANT | enumt=ENUM)
	 */
	protected void sequence_constant(ISerializationContext context, constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant_expression returns constant_expression
	 *
	 * Constraint:
	 *     conditional_expression=conditional_expression
	 */
	protected void sequence_constant_expression(ISerializationContext context, constant_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONSTANT_EXPRESSION__CONDITIONAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONSTANT_EXPRESSION__CONDITIONAL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstant_expressionAccess().getConditional_expressionConditional_expressionParserRuleCall_0(), semanticObject.getConditional_expression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declaration returns declaration
	 *
	 * Constraint:
	 *     (
	 *         declaration_specifiers=declaration_specifiers | 
	 *         (declaration_specifiers=declaration_specifiers init_declarator_list=init_declarator_list) | 
	 *         static_assert_declaration=static_assert_declaration
	 *     )
	 */
	protected void sequence_declaration(ISerializationContext context, declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declaration_list2 returns declaration_list2
	 *
	 * Constraint:
	 *     (declaration=declaration declaration_list2=declaration_list2)?
	 */
	protected void sequence_declaration_list2(ISerializationContext context, declaration_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declaration_list returns declaration_list
	 *
	 * Constraint:
	 *     (declaration=declaration declaration_list_2=declaration_list2)
	 */
	protected void sequence_declaration_list(ISerializationContext context, declaration_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION_LIST_2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATION_LIST__DECLARATION_LIST_2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaration_listAccess().getDeclarationDeclarationParserRuleCall_0_0(), semanticObject.getDeclaration());
		feeder.accept(grammarAccess.getDeclaration_listAccess().getDeclaration_list_2Declaration_list2ParserRuleCall_1_0(), semanticObject.getDeclaration_list_2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declaration_specifiers returns declaration_specifiers
	 *
	 * Constraint:
	 *     (
	 *         (storage_class_specifier=storage_class_specifier declaration_specifiers=declaration_specifiers) | 
	 *         storage_class_specifier=storage_class_specifier | 
	 *         (type_specifier=type_specifier declaration_specifiers=declaration_specifiers) | 
	 *         type_specifier=type_specifier | 
	 *         (type_qualifier=type_qualifier declaration_specifiers=declaration_specifiers) | 
	 *         type_qualifier=type_qualifier | 
	 *         (function_specifier=function_specifier declaration_specifiers=declaration_specifiers) | 
	 *         function_specifier=function_specifier | 
	 *         (alignment_specifier=alignment_specifier declaration_specifiers=declaration_specifiers) | 
	 *         alignment_specifier=alignment_specifier
	 *     )
	 */
	protected void sequence_declaration_specifiers(ISerializationContext context, declaration_specifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declarator returns declarator
	 *
	 * Constraint:
	 *     ((pointer=pointer direct_declarator=direct_declarator) | direct_declarator=direct_declarator)
	 */
	protected void sequence_declarator(ISerializationContext context, declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designation returns designation
	 *
	 * Constraint:
	 *     designator_list=designator_list
	 */
	protected void sequence_designation(ISerializationContext context, designation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DESIGNATION__DESIGNATOR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DESIGNATION__DESIGNATOR_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDesignationAccess().getDesignator_listDesignator_listParserRuleCall_0_0(), semanticObject.getDesignator_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     designator returns designator
	 *
	 * Constraint:
	 *     (constant_expression=constant_expression | identifier=ID)
	 */
	protected void sequence_designator(ISerializationContext context, designator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designator_list2 returns designator_list2
	 *
	 * Constraint:
	 *     (designator=designator designator_list2=designator_list2)?
	 */
	protected void sequence_designator_list2(ISerializationContext context, designator_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designator_list returns designator_list
	 *
	 * Constraint:
	 *     (designator=designator designator_list2=designator_list2)
	 */
	protected void sequence_designator_list(ISerializationContext context, designator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DESIGNATOR_LIST__DESIGNATOR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDesignator_listAccess().getDesignatorDesignatorParserRuleCall_0_0(), semanticObject.getDesignator());
		feeder.accept(grammarAccess.getDesignator_listAccess().getDesignator_list2Designator_list2ParserRuleCall_1_0(), semanticObject.getDesignator_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     direct_abstract_declarator2 returns direct_abstract_declarator2
	 *
	 * Constraint:
	 *     (
	 *         direct_abstract_declarator2=direct_abstract_declarator2 | 
	 *         direct_abstract_declarator2=direct_abstract_declarator2 | 
	 *         (
	 *             static=STATIC 
	 *             type_qualifier_list=type_qualifier_list 
	 *             assignment_expression=assignment_expression 
	 *             direct_abstract_declarator2=direct_abstract_declarator2
	 *         ) | 
	 *         (static=STATIC assignment_expression=assignment_expression direct_abstract_declarator2=direct_abstract_declarator2) | 
	 *         (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression direct_abstract_declarator2=direct_abstract_declarator2) | 
	 *         (
	 *             type_qualifier_list=type_qualifier_list 
	 *             static=STATIC 
	 *             assignment_expression=assignment_expression 
	 *             direct_abstract_declarator2=direct_abstract_declarator2
	 *         ) | 
	 *         (type_qualifier_list=type_qualifier_list direct_abstract_declarator2=direct_abstract_declarator2) | 
	 *         (assignment_expression=assignment_expression direct_abstract_declarator2=direct_abstract_declarator2) | 
	 *         direct_abstract_declarator2=direct_abstract_declarator2 | 
	 *         (parameter_type_list=parameter_type_list direct_abstract_declarator2=direct_abstract_declarator2)
	 *     )?
	 */
	protected void sequence_direct_abstract_declarator2(ISerializationContext context, direct_abstract_declarator2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_abstract_declarator returns direct_abstract_declarator
	 *
	 * Constraint:
	 *     (
	 *         (abstract_declarator=abstract_declarator direct_abstract_declarator2=direct_abstract_declarator2) | 
	 *         direct_abstract_declarator2=direct_abstract_declarator2 | 
	 *         direct_abstract_declarator2=direct_abstract_declarator2 | 
	 *         (
	 *             static=STATIC 
	 *             type_qualifier_list=type_qualifier_list 
	 *             assignment_expression=assignment_expression 
	 *             direct_abstract_declarator2=direct_abstract_declarator2
	 *         ) | 
	 *         (static=STATIC assignment_expression=assignment_expression direct_abstract_declarator2=direct_abstract_declarator2) | 
	 *         (
	 *             type_qualifier_list=type_qualifier_list 
	 *             static=STATIC 
	 *             assignment_expression=assignment_expression 
	 *             direct_abstract_declarator2=direct_abstract_declarator2
	 *         ) | 
	 *         (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression direct_abstract_declarator2=direct_abstract_declarator2) | 
	 *         (type_qualifier_list=type_qualifier_list direct_abstract_declarator2=direct_abstract_declarator2) | 
	 *         (assignment_expression=assignment_expression direct_abstract_declarator2=direct_abstract_declarator2) | 
	 *         direct_abstract_declarator2=direct_abstract_declarator2 | 
	 *         (parameter_type_list=parameter_type_list direct_abstract_declarator2=direct_abstract_declarator2)
	 *     )
	 */
	protected void sequence_direct_abstract_declarator(ISerializationContext context, direct_abstract_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_declarator2 returns direct_declarator2
	 *
	 * Constraint:
	 *     (
	 *         direct_declarator2=direct_declarator2 | 
	 *         direct_declarator2=direct_declarator2 | 
	 *         (static=STATIC type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression direct_declarator2=direct_declarator2) | 
	 *         (static=STATIC assignment_expression=assignment_expression direct_declarator2=direct_declarator2) | 
	 *         (type_qualifier_list=type_qualifier_list direct_declarator2=direct_declarator2) | 
	 *         (type_qualifier_list=type_qualifier_list static=STATIC assignment_expression=assignment_expression direct_declarator2=direct_declarator2) | 
	 *         (type_qualifier_list=type_qualifier_list assignment_expression=assignment_expression direct_declarator2=direct_declarator2) | 
	 *         (type_qualifier_list=type_qualifier_list direct_declarator2=direct_declarator2) | 
	 *         (assignment_expression=assignment_expression direct_declarator2=direct_declarator2) | 
	 *         (parameter_type_list=parameter_type_list direct_declarator2=direct_declarator2) | 
	 *         direct_declarator2=direct_declarator2 | 
	 *         (identifier_list=identifier_list direct_declarator2=direct_declarator2)
	 *     )?
	 */
	protected void sequence_direct_declarator2(ISerializationContext context, direct_declarator2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     direct_declarator returns direct_declarator
	 *
	 * Constraint:
	 *     ((name=ID direct_declarator2=direct_declarator2) | (declarator=declarator direct_declarator2=direct_declarator2))
	 */
	protected void sequence_direct_declarator(ISerializationContext context, direct_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     enum_specifier returns enum_specifier
	 *
	 * Constraint:
	 *     (
	 *         (enumt=ENUM enumerator_list=enumerator_list) | 
	 *         (enumt=ENUM enumerator_list=enumerator_list) | 
	 *         (enumt=ENUM identifier=ID enumerator_list=enumerator_list) | 
	 *         (enumt=ENUM identifier=ID enumerator_list=enumerator_list) | 
	 *         (enumt=ENUM identifier=ID)
	 *     )
	 */
	protected void sequence_enum_specifier(ISerializationContext context, enum_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     enumeration_constant returns enumeration_constant
	 *
	 * Constraint:
	 *     identifier=ID
	 */
	protected void sequence_enumeration_constant(ISerializationContext context, enumeration_constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATION_CONSTANT__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATION_CONSTANT__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumeration_constantAccess().getIdentifierIDTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     enumerator returns enumerator
	 *
	 * Constraint:
	 *     ((enumeration_constant=enumeration_constant constant_expression=constant_expression) | enumeration_constant=enumeration_constant)
	 */
	protected void sequence_enumerator(ISerializationContext context, enumerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     enumerator_list2 returns enumerator_list2
	 *
	 * Constraint:
	 *     (enumerator=enumerator enumerator_list2=enumerator_list2)
	 */
	protected void sequence_enumerator_list2(ISerializationContext context, enumerator_list2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST2__ENUMERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST2__ENUMERATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST2__ENUMERATOR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST2__ENUMERATOR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerator_list2Access().getEnumeratorEnumeratorParserRuleCall_1_0(), semanticObject.getEnumerator());
		feeder.accept(grammarAccess.getEnumerator_list2Access().getEnumerator_list2Enumerator_list2ParserRuleCall_2_0(), semanticObject.getEnumerator_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     enumerator_list returns enumerator_list
	 *
	 * Constraint:
	 *     (enumerator=enumerator enumerator_list2=enumerator_list2)
	 */
	protected void sequence_enumerator_list(ISerializationContext context, enumerator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMERATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMERATOR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUMERATOR_LIST__ENUMERATOR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerator_listAccess().getEnumeratorEnumeratorParserRuleCall_0_0(), semanticObject.getEnumerator());
		feeder.accept(grammarAccess.getEnumerator_listAccess().getEnumerator_list2Enumerator_list2ParserRuleCall_1_0(), semanticObject.getEnumerator_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     equality_expression2 returns equality_expression2
	 *
	 * Constraint:
	 *     (
	 *         (eq_op=EQ_OP relational_expression=relational_expression equality_expression2=equality_expression2) | 
	 *         (ne_op=NE_OP relational_expression=relational_expression equality_expression2=equality_expression2)
	 *     )?
	 */
	protected void sequence_equality_expression2(ISerializationContext context, equality_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     equality_expression returns equality_expression
	 *
	 * Constraint:
	 *     (relational_expression=relational_expression equality_expression2=equality_expression2)
	 */
	protected void sequence_equality_expression(ISerializationContext context, equality_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION__RELATIONAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION__RELATIONAL_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION__EQUALITY_EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUALITY_EXPRESSION__EQUALITY_EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquality_expressionAccess().getRelational_expressionRelational_expressionParserRuleCall_0_0(), semanticObject.getRelational_expression());
		feeder.accept(grammarAccess.getEquality_expressionAccess().getEquality_expression2Equality_expression2ParserRuleCall_1_0(), semanticObject.getEquality_expression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     exclusive_or_expression2 returns exclusive_or_expression2
	 *
	 * Constraint:
	 *     (and_expression=and_expression exclusive_or_expression2=exclusive_or_expression2)?
	 */
	protected void sequence_exclusive_or_expression2(ISerializationContext context, exclusive_or_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exclusive_or_expression returns exclusive_or_expression
	 *
	 * Constraint:
	 *     (and_expression=and_expression exclusive_or_expression2=exclusive_or_expression2)
	 */
	protected void sequence_exclusive_or_expression(ISerializationContext context, exclusive_or_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION__AND_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION__AND_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExclusive_or_expressionAccess().getAnd_expressionAnd_expressionParserRuleCall_0_0(), semanticObject.getAnd_expression());
		feeder.accept(grammarAccess.getExclusive_or_expressionAccess().getExclusive_or_expression2Exclusive_or_expression2ParserRuleCall_1_0(), semanticObject.getExclusive_or_expression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression2 returns expression2
	 *
	 * Constraint:
	 *     (assignment_expression=assignment_expression expression2=expression2)?
	 */
	protected void sequence_expression2(ISerializationContext context, expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expression returns expression
	 *
	 * Constraint:
	 *     (assignment_expression=assignment_expression expression2=expression2)
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION__ASSIGNMENT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION__ASSIGNMENT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION__EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION__EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getAssignment_expressionAssignment_expressionParserRuleCall_0_0(), semanticObject.getAssignment_expression());
		feeder.accept(grammarAccess.getExpressionAccess().getExpression2Expression2ParserRuleCall_1_0(), semanticObject.getExpression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression_statement returns expression_statement
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_expression_statement(ISerializationContext context, expression_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression_statementAccess().getExpressionExpressionParserRuleCall_1_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     external_declaration returns external_declaration
	 *
	 * Constraint:
	 *     (function_definition=function_definition | declaration=declaration)
	 */
	protected void sequence_external_declaration(ISerializationContext context, external_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     function_definition returns function_definition
	 *
	 * Constraint:
	 *     (
	 *         (declaration_specifiers=declaration_specifiers declarator=declarator declaration_list=declaration_list compound_statement=compound_statement) | 
	 *         (declaration_specifiers=declaration_specifiers declarator=declarator compound_statement=compound_statement)
	 *     )
	 */
	protected void sequence_function_definition(ISerializationContext context, function_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     function_specifier returns function_specifier
	 *
	 * Constraint:
	 *     (inline=INLINE | noreturn=NORETURN)
	 */
	protected void sequence_function_specifier(ISerializationContext context, function_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     generic_assoc_list2 returns generic_assoc_list2
	 *
	 * Constraint:
	 *     (generic_association=generic_association generic_assoc_list2=generic_assoc_list2)?
	 */
	protected void sequence_generic_assoc_list2(ISerializationContext context, generic_assoc_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     generic_assoc_list returns generic_assoc_list
	 *
	 * Constraint:
	 *     (generic_association=generic_association generic_assoc_list2=generic_assoc_list2)
	 */
	protected void sequence_generic_assoc_list(ISerializationContext context, generic_assoc_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERIC_ASSOC_LIST__GENERIC_ASSOCIATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERIC_ASSOC_LIST__GENERIC_ASSOCIATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERIC_ASSOC_LIST__GENERIC_ASSOC_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERIC_ASSOC_LIST__GENERIC_ASSOC_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneric_assoc_listAccess().getGeneric_associationGeneric_associationParserRuleCall_0_0(), semanticObject.getGeneric_association());
		feeder.accept(grammarAccess.getGeneric_assoc_listAccess().getGeneric_assoc_list2Generic_assoc_list2ParserRuleCall_1_0(), semanticObject.getGeneric_assoc_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     generic_association returns generic_association
	 *
	 * Constraint:
	 *     ((type_name=type_name assignment_expression=assignment_expression) | (default=DEFAULT assignment_expression=assignment_expression))
	 */
	protected void sequence_generic_association(ISerializationContext context, generic_association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     generic_selection returns generic_selection
	 *
	 * Constraint:
	 *     (generic=GENERIC assignment_expression=assignment_expression generic_assoc_list=generic_assoc_list)
	 */
	protected void sequence_generic_selection(ISerializationContext context, generic_selection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__GENERIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__GENERIC));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__ASSIGNMENT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__ASSIGNMENT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__GENERIC_ASSOC_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERIC_SELECTION__GENERIC_ASSOC_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneric_selectionAccess().getGenericGENERICParserRuleCall_0_0(), semanticObject.getGeneric());
		feeder.accept(grammarAccess.getGeneric_selectionAccess().getAssignment_expressionAssignment_expressionParserRuleCall_2_0(), semanticObject.getAssignment_expression());
		feeder.accept(grammarAccess.getGeneric_selectionAccess().getGeneric_assoc_listGeneric_assoc_listParserRuleCall_4_0(), semanticObject.getGeneric_assoc_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     identifier_list2 returns identifier_list2
	 *
	 * Constraint:
	 *     (identifier=ID identifier_list2=identifier_list2)?
	 */
	protected void sequence_identifier_list2(ISerializationContext context, identifier_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     identifier_list returns identifier_list
	 *
	 * Constraint:
	 *     (identifier=ID identifier_list2=identifier_list2)
	 */
	protected void sequence_identifier_list(ISerializationContext context, identifier_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IDENTIFIER_LIST__IDENTIFIER_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentifier_listAccess().getIdentifierIDTerminalRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getIdentifier_listAccess().getIdentifier_list2Identifier_list2ParserRuleCall_1_0(), semanticObject.getIdentifier_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     inclusive_or_expression2 returns inclusive_or_expression2
	 *
	 * Constraint:
	 *     (exclusive_or_expression=exclusive_or_expression inclusive_or_expression2=inclusive_or_expression2)?
	 */
	protected void sequence_inclusive_or_expression2(ISerializationContext context, inclusive_or_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     inclusive_or_expression returns inclusive_or_expression
	 *
	 * Constraint:
	 *     (exclusive_or_expression=exclusive_or_expression inclusive_or_expression2=inclusive_or_expression2)
	 */
	protected void sequence_inclusive_or_expression(ISerializationContext context, inclusive_or_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION__INCLUSIVE_OR_EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INCLUSIVE_OR_EXPRESSION__INCLUSIVE_OR_EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInclusive_or_expressionAccess().getExclusive_or_expressionExclusive_or_expressionParserRuleCall_0_0(), semanticObject.getExclusive_or_expression());
		feeder.accept(grammarAccess.getInclusive_or_expressionAccess().getInclusive_or_expression2Inclusive_or_expression2ParserRuleCall_1_0(), semanticObject.getInclusive_or_expression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator returns init_declarator
	 *
	 * Constraint:
	 *     ((declarator=declarator initializer=initializer) | declarator=declarator)
	 */
	protected void sequence_init_declarator(ISerializationContext context, init_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator_list2 returns init_declarator_list2
	 *
	 * Constraint:
	 *     (init_declarator=init_declarator init_declarator_list2=init_declarator_list2)?
	 */
	protected void sequence_init_declarator_list2(ISerializationContext context, init_declarator_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     init_declarator_list returns init_declarator_list
	 *
	 * Constraint:
	 *     (init_declarator=init_declarator init_declarator_list2=init_declarator_list2)
	 */
	protected void sequence_init_declarator_list(ISerializationContext context, init_declarator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INIT_DECLARATOR_LIST__INIT_DECLARATOR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInit_declarator_listAccess().getInit_declaratorInit_declaratorParserRuleCall_0_0(), semanticObject.getInit_declarator());
		feeder.accept(grammarAccess.getInit_declarator_listAccess().getInit_declarator_list2Init_declarator_list2ParserRuleCall_1_0(), semanticObject.getInit_declarator_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     initializer returns initializer
	 *
	 * Constraint:
	 *     (initializer_list=initializer_list | initializer_list=initializer_list | assignment_expression=assignment_expression)
	 */
	protected void sequence_initializer(ISerializationContext context, initializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initializer_list2 returns initializer_list2
	 *
	 * Constraint:
	 *     (
	 *         (designation=designation initializer=initializer initializer_list2=initializer_list2) | 
	 *         (initializer=initializer initializer_list2=initializer_list2)
	 *     )?
	 */
	protected void sequence_initializer_list2(ISerializationContext context, initializer_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initializer_list returns initializer_list
	 *
	 * Constraint:
	 *     (
	 *         (designation=designation initializer=initializer initializer_list2=initializer_list2) | 
	 *         (initializer=initializer initializer_list2=initializer_list2)
	 *     )
	 */
	protected void sequence_initializer_list(ISerializationContext context, initializer_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     iteration_statement returns iteration_statement
	 *
	 * Constraint:
	 *     (
	 *         (while=WHILE expression=expression statement=statement) | 
	 *         (do=DO statement=statement while=WHILE expression=expression) | 
	 *         (for=FOR expression_statement=expression_statement expression_statement2=expression_statement statement=statement) | 
	 *         (for=FOR expression_statement=expression_statement expression_statement2=expression_statement expression=expression statement=statement) | 
	 *         (for=FOR declaration=declaration expression_statement=expression_statement statement=statement) | 
	 *         (for=FOR declaration=declaration expression_statement=expression_statement expression=expression statement=statement)
	 *     )
	 */
	protected void sequence_iteration_statement(ISerializationContext context, iteration_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     jump_statement returns jump_statement
	 *
	 * Constraint:
	 *     ((goto=GOTO identifier=ID) | continue=CONTINUE | break=BREAK | return=RETURN | (return=RETURN expression=expression))
	 */
	protected void sequence_jump_statement(ISerializationContext context, jump_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     labeled_statement returns labeled_statement
	 *
	 * Constraint:
	 *     (
	 *         (identifier=ID statement=statement) | 
	 *         (case=CASE constant_expression=constant_expression statement=statement) | 
	 *         (default=DEFAULT statement=statement)
	 *     )
	 */
	protected void sequence_labeled_statement(ISerializationContext context, labeled_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     logical_and_expression2 returns logical_and_expression2
	 *
	 * Constraint:
	 *     (and_op=AND_OP inclusive_or_expression=inclusive_or_expression logical_and_expression2=logical_and_expression2)?
	 */
	protected void sequence_logical_and_expression2(ISerializationContext context, logical_and_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     logical_and_expression returns logical_and_expression
	 *
	 * Constraint:
	 *     (inclusive_or_expression=inclusive_or_expression logical_and_expression2=logical_and_expression2)
	 */
	protected void sequence_logical_and_expression(ISerializationContext context, logical_and_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION__INCLUSIVE_OR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION__INCLUSIVE_OR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION__LOGICAL_AND_EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_AND_EXPRESSION__LOGICAL_AND_EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogical_and_expressionAccess().getInclusive_or_expressionInclusive_or_expressionParserRuleCall_0_0(), semanticObject.getInclusive_or_expression());
		feeder.accept(grammarAccess.getLogical_and_expressionAccess().getLogical_and_expression2Logical_and_expression2ParserRuleCall_1_0(), semanticObject.getLogical_and_expression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     logical_or_expression2 returns logical_or_expression2
	 *
	 * Constraint:
	 *     (or_op=OR_OP logical_and_expression=logical_and_expression logical_or_expression2=logical_or_expression2)?
	 */
	protected void sequence_logical_or_expression2(ISerializationContext context, logical_or_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     logical_or_expression returns logical_or_expression
	 *
	 * Constraint:
	 *     (logical_and_expression=logical_and_expression logical_or_expression2=logical_or_expression2)
	 */
	protected void sequence_logical_or_expression(ISerializationContext context, logical_or_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_AND_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_AND_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_OR_EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_OR_EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogical_or_expressionAccess().getLogical_and_expressionLogical_and_expressionParserRuleCall_0_0(), semanticObject.getLogical_and_expression());
		feeder.accept(grammarAccess.getLogical_or_expressionAccess().getLogical_or_expression2Logical_or_expression2ParserRuleCall_1_0(), semanticObject.getLogical_or_expression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     multiplicative_expression2 returns multiplicative_expression2
	 *
	 * Constraint:
	 *     (
	 *         (cast_expression=cast_expression multiplicative_expression2=multiplicative_expression2) | 
	 *         (cast_expression=cast_expression multiplicative_expression2=multiplicative_expression2) | 
	 *         (cast_expression=cast_expression multiplicative_expression2=multiplicative_expression2)
	 *     )?
	 */
	protected void sequence_multiplicative_expression2(ISerializationContext context, multiplicative_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     multiplicative_expression returns multiplicative_expression
	 *
	 * Constraint:
	 *     (cast_expression=cast_expression multiplicative_expression2=multiplicative_expression2)
	 */
	protected void sequence_multiplicative_expression(ISerializationContext context, multiplicative_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION__CAST_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION__CAST_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTIPLICATIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicative_expressionAccess().getCast_expressionCast_expressionParserRuleCall_0_0(), semanticObject.getCast_expression());
		feeder.accept(grammarAccess.getMultiplicative_expressionAccess().getMultiplicative_expression2Multiplicative_expression2ParserRuleCall_1_0(), semanticObject.getMultiplicative_expression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameter_declaration returns parameter_declaration
	 *
	 * Constraint:
	 *     (
	 *         (declaration_specifiers=declaration_specifiers declarator=declarator) | 
	 *         (declaration_specifiers=declaration_specifiers abstract_declarator=abstract_declarator) | 
	 *         declaration_specifiers=declaration_specifiers
	 *     )
	 */
	protected void sequence_parameter_declaration(ISerializationContext context, parameter_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_list2 returns parameter_list2
	 *
	 * Constraint:
	 *     (parameter_declaration=parameter_declaration parameter_list2=parameter_list2)?
	 */
	protected void sequence_parameter_list2(ISerializationContext context, parameter_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter_list returns parameter_list
	 *
	 * Constraint:
	 *     (parameter_declaration=parameter_declaration parameter_list2=parameter_list2)
	 */
	protected void sequence_parameter_list(ISerializationContext context, parameter_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PARAMETER_LIST__PARAMETER_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PARAMETER_LIST__PARAMETER_DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PARAMETER_LIST__PARAMETER_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PARAMETER_LIST__PARAMETER_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameter_listAccess().getParameter_declarationParameter_declarationParserRuleCall_0_0(), semanticObject.getParameter_declaration());
		feeder.accept(grammarAccess.getParameter_listAccess().getParameter_list2Parameter_list2ParserRuleCall_1_0(), semanticObject.getParameter_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameter_type_list returns parameter_type_list
	 *
	 * Constraint:
	 *     ((parameter_list=parameter_list ellipsis=ELLIPSIS) | parameter_list=parameter_list)
	 */
	protected void sequence_parameter_type_list(ISerializationContext context, parameter_type_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     pointer returns pointer
	 *
	 * Constraint:
	 *     ((type_qualifier_list=type_qualifier_list pointer=pointer) | type_qualifier_list=type_qualifier_list | pointer=pointer)
	 */
	protected void sequence_pointer(ISerializationContext context, pointer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expression2 returns postfix_expression2
	 *
	 * Constraint:
	 *     (
	 *         (expression=expression postfix_expression2=postfix_expression2) | 
	 *         postfix_expression2=postfix_expression2 | 
	 *         (argument_expression_list=argument_expression_list postfix_expression2=postfix_expression2) | 
	 *         (identifier=ID postfix_expression2=postfix_expression2) | 
	 *         (ptr_op=PTR_OP identifier=ID postfix_expression2=postfix_expression2) | 
	 *         (inc_op=INC_OP postfix_expression2=postfix_expression2) | 
	 *         (dec_op=DEC_OP postfix_expression2=postfix_expression2)
	 *     )?
	 */
	protected void sequence_postfix_expression2(ISerializationContext context, postfix_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postfix_expression returns postfix_expression
	 *
	 * Constraint:
	 *     (
	 *         (primary_expression=primary_expression postfix_expression2=postfix_expression2) | 
	 *         (type_name=type_name initializer_list=initializer_list postfix_expression2=postfix_expression2) | 
	 *         (type_name=type_name initializer_list=initializer_list postfix_expression2=postfix_expression2)
	 *     )
	 */
	protected void sequence_postfix_expression(ISerializationContext context, postfix_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primary_expression returns primary_expression
	 *
	 * Constraint:
	 *     (identifier=[direct_declarator|ID] | constant=constant | string=string_nova | expression=expression | generic_selection=generic_selection)
	 */
	protected void sequence_primary_expression(ISerializationContext context, primary_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     relational_expression2 returns relational_expression2
	 *
	 * Constraint:
	 *     (
	 *         (shift_expression=shift_expression relational_expression2=relational_expression2) | 
	 *         (shift_expression=shift_expression relational_expression=relational_expression2) | 
	 *         (le_op=LE_OP shift_expression=shift_expression relational_expression2=relational_expression2) | 
	 *         (ge_op=GE_OP shift_expression=shift_expression relational_expression2=relational_expression2)
	 *     )?
	 */
	protected void sequence_relational_expression2(ISerializationContext context, relational_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     relational_expression returns relational_expression
	 *
	 * Constraint:
	 *     (shift_expression=shift_expression relational_expression2=relational_expression2)
	 */
	protected void sequence_relational_expression(ISerializationContext context, relational_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION__SHIFT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION__SHIFT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION__RELATIONAL_EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RELATIONAL_EXPRESSION__RELATIONAL_EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelational_expressionAccess().getShift_expressionShift_expressionParserRuleCall_0_0(), semanticObject.getShift_expression());
		feeder.accept(grammarAccess.getRelational_expressionAccess().getRelational_expression2Relational_expression2ParserRuleCall_1_0(), semanticObject.getRelational_expression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     selection_statement returns selection_statement
	 *
	 * Constraint:
	 *     (
	 *         (if=IF expression=expression statement=statement else=ELSE statement2=statement) | 
	 *         (if=IF expression=expression statement=statement) | 
	 *         (switch=SWITCH expression=expression statement=statement)
	 *     )
	 */
	protected void sequence_selection_statement(ISerializationContext context, selection_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     shift_expression2 returns shift_expression2
	 *
	 * Constraint:
	 *     (
	 *         (left_op=LEFT_OP additive_expression=additive_expression shift_expression2=shift_expression2) | 
	 *         (right_op=RIGHT_OP additive_expression=additive_expression shift_expression2=shift_expression2)
	 *     )?
	 */
	protected void sequence_shift_expression2(ISerializationContext context, shift_expression2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     shift_expression returns shift_expression
	 *
	 * Constraint:
	 *     (additive_expression=additive_expression shift_expression2=shift_expression2)
	 */
	protected void sequence_shift_expression(ISerializationContext context, shift_expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION__ADDITIVE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION__ADDITIVE_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION__SHIFT_EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHIFT_EXPRESSION__SHIFT_EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShift_expressionAccess().getAdditive_expressionAdditive_expressionParserRuleCall_0_0(), semanticObject.getAdditive_expression());
		feeder.accept(grammarAccess.getShift_expressionAccess().getShift_expression2Shift_expression2ParserRuleCall_1_0(), semanticObject.getShift_expression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     specifier_qualifier_list returns specifier_qualifier_list
	 *
	 * Constraint:
	 *     (
	 *         (type_specifier=type_specifier specifier_qualifier_list=specifier_qualifier_list) | 
	 *         type_specifier=type_specifier | 
	 *         (type_qualifier=type_specifier specifier_qualifier_list=specifier_qualifier_list) | 
	 *         type_qualifier=type_specifier
	 *     )
	 */
	protected void sequence_specifier_qualifier_list(ISerializationContext context, specifier_qualifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     (
	 *         labeled_statement=labeled_statement | 
	 *         compound_statement=compound_statement | 
	 *         expression_statement=expression_statement | 
	 *         selection_statement=selection_statement | 
	 *         iteration_statement=iteration_statement | 
	 *         jump_statement=jump_statement
	 *     )
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     static_assert_declaration returns static_assert_declaration
	 *
	 * Constraint:
	 *     (static_assert=STATIC_ASSERT constant_expression=constant_expression string_literal=STRING_LITERAL)
	 */
	protected void sequence_static_assert_declaration(ISerializationContext context, static_assert_declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__STATIC_ASSERT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__STATIC_ASSERT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__CONSTANT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__CONSTANT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__STRING_LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STATIC_ASSERT_DECLARATION__STRING_LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatic_assert_declarationAccess().getStatic_assertSTATIC_ASSERTParserRuleCall_0_0(), semanticObject.getStatic_assert());
		feeder.accept(grammarAccess.getStatic_assert_declarationAccess().getConstant_expressionConstant_expressionParserRuleCall_2_0(), semanticObject.getConstant_expression());
		feeder.accept(grammarAccess.getStatic_assert_declarationAccess().getString_literalSTRING_LITERALTerminalRuleCall_4_0(), semanticObject.getString_literal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     storage_class_specifier returns storage_class_specifier
	 *
	 * Constraint:
	 *     (
	 *         typedef=TYPEDEF | 
	 *         extern=EXTERN | 
	 *         static=STATIC | 
	 *         thread_local=THREAD_LOCAL | 
	 *         auto=AUTO | 
	 *         register=REGISTER
	 *     )
	 */
	protected void sequence_storage_class_specifier(ISerializationContext context, storage_class_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     string_nova returns string_nova
	 *
	 * Constraint:
	 *     (string_literal=STRING_LITERAL | func_name=FUNC_NAME)
	 */
	protected void sequence_string_nova(ISerializationContext context, string_nova semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration_list2 returns struct_declaration_list2
	 *
	 * Constraint:
	 *     (struct_declaration=struct_declaration struct_declaration_list2=struct_declaration_list2)
	 */
	protected void sequence_struct_declaration_list2(ISerializationContext context, struct_declaration_list2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST2__STRUCT_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST2__STRUCT_DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST2__STRUCT_DECLARATION_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST2__STRUCT_DECLARATION_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStruct_declaration_list2Access().getStruct_declarationStruct_declarationParserRuleCall_0_0(), semanticObject.getStruct_declaration());
		feeder.accept(grammarAccess.getStruct_declaration_list2Access().getStruct_declaration_list2Struct_declaration_list2ParserRuleCall_1_0(), semanticObject.getStruct_declaration_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration_list returns struct_declaration_list
	 *
	 * Constraint:
	 *     (struct_declaration=struct_declaration struct_declaration_list2=struct_declaration_list2)
	 */
	protected void sequence_struct_declaration_list(ISerializationContext context, struct_declaration_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATION_LIST__STRUCT_DECLARATION_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStruct_declaration_listAccess().getStruct_declarationStruct_declarationParserRuleCall_0_0(), semanticObject.getStruct_declaration());
		feeder.accept(grammarAccess.getStruct_declaration_listAccess().getStruct_declaration_list2Struct_declaration_list2ParserRuleCall_1_0(), semanticObject.getStruct_declaration_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     struct_declaration returns struct_declaration
	 *
	 * Constraint:
	 *     (
	 *         specifier_qualifier_list=specifier_qualifier_list | 
	 *         (specifier_qualifier_list=specifier_qualifier_list struct_declarator_list=struct_declarator_list) | 
	 *         static_assert_declaration=static_assert_declaration
	 *     )
	 */
	protected void sequence_struct_declaration(ISerializationContext context, struct_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator_list2 returns struct_declarator_list2
	 *
	 * Constraint:
	 *     (struct_declarator=struct_declarator struct_declarator_list2=struct_declarator_list2)?
	 */
	protected void sequence_struct_declarator_list2(ISerializationContext context, struct_declarator_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator_list returns struct_declarator_list
	 *
	 * Constraint:
	 *     (struct_declarator=struct_declarator struct_declarator_list2=struct_declarator_list2)
	 */
	protected void sequence_struct_declarator_list(ISerializationContext context, struct_declarator_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRUCT_DECLARATOR_LIST__STRUCT_DECLARATOR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStruct_declarator_listAccess().getStruct_declaratorStruct_declaratorParserRuleCall_0_0(), semanticObject.getStruct_declarator());
		feeder.accept(grammarAccess.getStruct_declarator_listAccess().getStruct_declarator_list2Struct_declarator_list2ParserRuleCall_1_0(), semanticObject.getStruct_declarator_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     struct_declarator returns struct_declarator
	 *
	 * Constraint:
	 *     (constant_expression=constant_expression | (declarator=declarator constant_expression=constant_expression) | declarator=declarator)
	 */
	protected void sequence_struct_declarator(ISerializationContext context, struct_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_or_union_specifier returns struct_or_union_specifier
	 *
	 * Constraint:
	 *     (
	 *         (struct_or_union=struct_or_union struct_declaration_list=struct_declaration_list) | 
	 *         (struct_or_union=struct_or_union identifier=ID struct_declaration_list=struct_declaration_list)
	 *     )
	 */
	protected void sequence_struct_or_union_specifier(ISerializationContext context, struct_or_union_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_or_union returns struct_or_union
	 *
	 * Constraint:
	 *     (struct=STRUCT | union=UNION)
	 */
	protected void sequence_struct_or_union(ISerializationContext context, struct_or_union semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     struct_or_union_specifier returns struct_or_union
	 *
	 * Constraint:
	 *     ((struct=STRUCT | union=UNION) identifier=ID)
	 */
	protected void sequence_struct_or_union_struct_or_union_specifier(ISerializationContext context, struct_or_union semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     translation_unit returns translation_unit
	 *
	 * Constraint:
	 *     external_declaration=external_declaration
	 */
	protected void sequence_translation_unit(ISerializationContext context, translation_unit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRANSLATION_UNIT__EXTERNAL_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRANSLATION_UNIT__EXTERNAL_DECLARATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTranslation_unitAccess().getExternal_declarationExternal_declarationParserRuleCall_0(), semanticObject.getExternal_declaration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_name returns type_name
	 *
	 * Constraint:
	 *     ((specifier_qualifier_list=specifier_qualifier_list abstract_declarator=abstract_declarator) | specifier_qualifier_list=specifier_qualifier_list)
	 */
	protected void sequence_type_name(ISerializationContext context, type_name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier_list2 returns type_qualifier_list2
	 *
	 * Constraint:
	 *     (type_qualifier=type_qualifier type_qualifier_list2=type_qualifier_list2)?
	 */
	protected void sequence_type_qualifier_list2(ISerializationContext context, type_qualifier_list2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier_list returns type_qualifier_list
	 *
	 * Constraint:
	 *     (type_qualifier=type_qualifier type_qualifier_list2=type_qualifier_list2)
	 */
	protected void sequence_type_qualifier_list(ISerializationContext context, type_qualifier_list semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_QUALIFIER_LIST__TYPE_QUALIFIER_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_qualifier_listAccess().getType_qualifierType_qualifierParserRuleCall_0_0(), semanticObject.getType_qualifier());
		feeder.accept(grammarAccess.getType_qualifier_listAccess().getType_qualifier_list2Type_qualifier_list2ParserRuleCall_1_0(), semanticObject.getType_qualifier_list2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_qualifier returns type_qualifier
	 *
	 * Constraint:
	 *     (const=CONST | restrict=RESTRICT | volatile=VOLATILE | atomic=ATOMIC)
	 */
	protected void sequence_type_qualifier(ISerializationContext context, type_qualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns integer
	 *
	 * Constraint:
	 *     int_type=INTNAME
	 */
	protected void sequence_type_specifier(ISerializationContext context, integer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INTEGER__INT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INTEGER__INT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_specifierAccess().getInt_typeINTNAMEParserRuleCall_3_1_0(), semanticObject.getInt_type());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type_specifier returns type_specifier
	 *
	 * Constraint:
	 *     (
	 *         void_type=VOID | 
	 *         char_type=CHAR | 
	 *         short_type=SHORT | 
	 *         long_type=LONG | 
	 *         float_type=FLOAT | 
	 *         double_type=DOUBLE | 
	 *         signed_type=SIGNED | 
	 *         unsigned_type=UNSIGNED | 
	 *         bool_type=BOOL | 
	 *         complex_type=COMPLEX | 
	 *         imaginary_type=IMAGINARY | 
	 *         atomic_type_specifier=atomic_type_specifier | 
	 *         struct_or_union_specifier=struct_or_union_specifier | 
	 *         enum_specifier=enum_specifier | 
	 *         typedef_name=TYPEDEF
	 *     )
	 */
	protected void sequence_type_specifier(ISerializationContext context, type_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unary_expression returns unary_expression
	 *
	 * Constraint:
	 *     (
	 *         postfix_expression=postfix_expression | 
	 *         (inc_op=INC_OP unary_expression=unary_expression) | 
	 *         (dec_op=DEC_OP unary_expression=unary_expression) | 
	 *         (unary_operator=unary_operator cast_expression=cast_expression) | 
	 *         (sizeof=SIZEOF unary_expression=unary_expression) | 
	 *         (sizeof=SIZEOF type_name=type_name) | 
	 *         (alignof=ALIGNOF type_name=type_name)
	 *     )
	 */
	protected void sequence_unary_expression(ISerializationContext context, unary_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
